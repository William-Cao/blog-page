<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    


<!-- Baidu Push -->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- End Baidu Push -->

    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="21k73v5G8oRoUeP-cTwUyeD5lkZ5asW5K667uxY6oqI">
    
    
    <meta name="baidu-site-verification" content="I1QHrtH1Ea">
    
    
    
    <link rel="canonical" href="https://www.williamife.com//2020/05/29/React常见问题汇总/">
    
    
    <title>React常见问题汇总 | 我的博客 | What&#39;s past is prologue.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,React">
    <meta name="description" content="-什么是JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。 12345678910class MyComponent extends React.Component &amp;#123;  ren">
<meta name="keywords" content="JavaScript,React">
<meta property="og:type" content="article">
<meta property="og:title" content="React常见问题汇总">
<meta property="og:url" content="https://www.williamife.com/2020/05/29/React常见问题汇总/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="-什么是JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。 12345678910class MyComponent extends React.Component &amp;#123;  ren">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.williamife.com/img/images/lifecycle.png">
<meta property="og:updated_time" content="2020-10-13T09:56:42.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React常见问题汇总">
<meta name="twitter:description" content="-什么是JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。 12345678910class MyComponent extends React.Component &amp;#123;  ren">
<meta name="twitter:image" content="https://www.williamife.com/img/images/lifecycle.png">
    
        <link rel="alternate" type="application/atom+xml" title="我的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">William Cao</h5>
          <a href="mailto:demondora@qq.com" title="demondora@qq.com" class="mail">demondora@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5c6664e66fb9a049b41cfdda" target="_blank" >
                <i class="icon icon-lg icon-juejin"></i>
                掘金
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/William-Cao" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.weibo.com/" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">React常见问题汇总</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">React常见问题汇总</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-05-29T06:05:00.000Z" itemprop="datePublished" class="page-time">
  2020-05-29
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <!-- <h4>TOC</h4> -->
            <h4>文章目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是JSX"><span class="post-toc-text">-什么是JSX</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是虚拟DOM"><span class="post-toc-text">-什么是虚拟DOM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么虚拟DOM会提高性能"><span class="post-toc-text">-为什么虚拟DOM会提高性能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-diff原理"><span class="post-toc-text">-React diff原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React中key的作用是什么"><span class="post-toc-text">-React中key的作用是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么不直接更新state状态"><span class="post-toc-text">-为什么不直接更新state状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调用setState之后发生了什么"><span class="post-toc-text">-调用setState之后发生了什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么建议传递给setState的参数是一个callback"><span class="post-toc-text">-为什么建议传递给setState的参数是一个callback</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React生命周期函数-v16-4"><span class="post-toc-text">-React生命周期函数(v16.4)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-性能优化是哪个周期函数"><span class="post-toc-text">-React 性能优化是哪个周期函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React中refs的作用是什么"><span class="post-toc-text">-React中refs的作用是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何创建refs"><span class="post-toc-text">-如何创建refs</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#展示组件和容器组件之间有何不同"><span class="post-toc-text">-展示组件和容器组件之间有何不同</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类组件和函数组件之间有什么区别"><span class="post-toc-text">-类组件和函数组件之间有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组件的状态-state-和属性-props-之间有何不同"><span class="post-toc-text">-组件的状态(state)和属性(props)之间有何不同</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何为受控组件-controlled-component"><span class="post-toc-text">-何为受控组件(controlled component)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在构造函数中调用-super-props-的目的是什么"><span class="post-toc-text">-在构造函数中调用 super(props) 的目的是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#何为高阶组件-higher-order-component"><span class="post-toc-text">-何为高阶组件(higher order component)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#除了在构造函数中绑定-this，还有其它方式吗"><span class="post-toc-text">-除了在构造函数中绑定 this，还有其它方式吗</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应该在-React-组件的何处发起-Ajax-请求"><span class="post-toc-text">-应该在 React 组件的何处发起 Ajax 请求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#描述事件在-React-中的处理方式"><span class="post-toc-text">-描述事件在 React 中的处理方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#createElement-和-cloneElement-有什么区别"><span class="post-toc-text">-createElement 和 cloneElement 有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React中有三种构建组件的方式"><span class="post-toc-text">-React中有三种构建组件的方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#以下使用React-createElement的等价项是什么"><span class="post-toc-text">-以下使用React.createElement的等价项是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用React-Hooks有什么优势"><span class="post-toc-text">-使用React Hooks有什么优势</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么类方法需要绑定"><span class="post-toc-text">-为什么类方法需要绑定</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简述-flux-思想"><span class="post-toc-text">-简述 flux 思想</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简述-redux-思想"><span class="post-toc-text">-简述 redux 思想</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#redux-有什么缺点"><span class="post-toc-text">-redux 有什么缺点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#描述Flux与MVC"><span class="post-toc-text">-描述Flux与MVC</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-Context是什么"><span class="post-toc-text">-React Context是什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#React-Fiber是什么"><span class="post-toc-text">-React Fiber是什么</span></a></li></ol>
        </nav>
    </aside>


<article id="post-React常见问题汇总"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">React常见问题汇总</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-05-29 14:05:00" datetime="2020-05-29T06:05:00.000Z"  itemprop="datePublished">2020-05-29</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="-什么是JSX"></a>-什么是JSX</h3><p>即<code>JavaScript XML</code>。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let props = this.props;  </span><br><span class="line">    return (</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"my-component"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;props.url&#125;</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：<br>1.允许使用熟悉的语法来定义 HTML 元素树；<br>2.提供更加语义化且移动的标签；<br>3.程序结构更容易被直观化；<br>4.抽象了 React Element 的创建过程；<br>5.可以随时掌控 HTML 标签以及生成这些标签的代码；<br>6.是原生的 JavaScript。</p>
<hr>
<h3 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="-什么是虚拟DOM"></a>-什么是虚拟DOM</h3><p>虚拟DOM（VDOM）它是真实DOM的内存表示,一种编程概念，一种模式。它会和真实的DOM同步，比如通过ReactDOM这种库，这个同步的过程叫做<code>调和(Reconciliation)</code>。<br>虚拟DOM更多是一种模式，不是一种特定的技术。</p>
<hr>
<h3 id="为什么虚拟DOM会提高性能"><a href="#为什么虚拟DOM会提高性能" class="headerlink" title="-为什么虚拟DOM会提高性能"></a>-为什么虚拟DOM会提高性能</h3><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<hr>
<h3 id="React-diff原理"><a href="#React-diff原理" class="headerlink" title="-React diff原理"></a>-React diff原理</h3><p>把树形结构按照层级分解，只比较同级元素。<br>给列表结构的每个单元添加唯一的 key 属性，方便比较。<br>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.<br>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
<hr>
<h3 id="React中key的作用是什么"><a href="#React中key的作用是什么" class="headerlink" title="-React中key的作用是什么"></a>-React中key的作用是什么</h3><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.state.todoItems.map(<span class="function">(<span class="params">&#123;item, key&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;key&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</em></strong></p>
<hr>
<h3 id="为什么不直接更新state状态"><a href="#为什么不直接更新state状态" class="headerlink" title="-为什么不直接更新state状态"></a>-为什么不直接更新state状态</h3><p>如果进行如下方式更新状态，那么它将不会重新渲染组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wrong</span></span><br><span class="line">This.state.message =”Hello world”;</span><br></pre></td></tr></table></figure>
<p>而是使用 setState() 方法。它计划对组件状态对象的更新。状态改变时，组件通过重新渲染做出响应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Correct</span></span><br><span class="line">This.setState(&#123;<span class="attr">message</span>: ‘Hello World’&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：可以分配状态的唯一位置是构造函数。</p>
<hr>
<h3 id="调用setState之后发生了什么"><a href="#调用setState之后发生了什么" class="headerlink" title="-调用setState之后发生了什么"></a>-调用setState之后发生了什么</h3><p>在代码中调用 <code>setState</code> 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的<code>调和过程（Reconciliation）</code>。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<hr>
<h3 id="为什么建议传递给setState的参数是一个callback"><a href="#为什么建议传递给setState的参数是一个callback" class="headerlink" title="-为什么建议传递给setState的参数是一个callback"></a>-为什么建议传递给setState的参数是一个callback</h3><p>为什么建议传递给setState的参数是一个callback而不是一个对象?<br>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个state。</p>
<hr>
<h3 id="React生命周期函数-v16-4"><a href="#React生命周期函数-v16-4" class="headerlink" title="-React生命周期函数(v16.4)"></a>-React生命周期函数(v16.4)</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/img/images/lifecycle.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>1.constructor(props)</strong></p>
<blockquote>
<p>react组件的构造函数在挂载之前被调用。在实现<code>React.Component</code>构造函数时，需要先在添加其他内容前，调用<code>super(props)</code>，用来将父组件传来的<code>props</code>绑定到这个类中，使用<code>this.props</code>将会得到。</p>
</blockquote>
<p><strong><em>官方建议：不要在constructor引入任何具有副作用和订阅功能的代码，这些应当在componentDidMount()中写入。</em></strong></p>
<p><code>constructor</code>中应当做些初始化的动作，如：初始化state，将事件处理函数绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。</p>
<p>当然也可以利用props初始化state，在之后修改state不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用redux统一进行状态管理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    color: props.initialColor</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.static getDerivedStateFromProps(nextProps, prevState)</strong></p>
<blockquote>
<p><code>getDerivedStateFromProps</code>在组件实例化后，和接受新的<code>props</code>后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。</p>
</blockquote>
<p>如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。调用setState()不会触发getDerivedStateFromProps()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      list: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'up'</span>,props, state.list)</span><br><span class="line">  <span class="keyword">if</span> (state.list.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'down'</span>,props.list, state.list)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">list</span> : props.list&#125;; <span class="comment">//props.list</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><s>componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)</s></strong></p>
<blockquote>
<p>官方建议使用<code>getDerivedStateFromProps</code>函数代替<code>componentWillReceiveProps()</code>。当组件挂载后，接收到新的<code>props</code>后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用<code>this.setState()</code>。</p>
</blockquote>
<p>如果父组件会让这个组件重新渲染，即使<code>props</code>没有改变，也会调用这个方法。react不会在组件初始化props时调用这个方法。调用<code>this.setState</code>也不会触发。</p>
<p><strong>3.render()</strong></p>
<blockquote>
<p><code>render()</code>方法是必需的。当他被调用时，他将计算<code>this.props</code>和<code>this.state</code>，并返回以下一种类型：</p>
</blockquote>
<ul>
<li><code>React元素</code>通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。</li>
<li><code>字符串或数字</code>他们将会以文本节点形式渲染到dom中。</li>
<li><code>Portals</code>react16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。</li>
<li><code></code> 什么也不渲染</li>
<li><code>布尔值</code> 也是什么都不渲染，通常后跟组件进行判断。</li>
</ul>
<p>当返回<code></code>,<code>false</code>,<code>ReactDOM.findDOMNode(this)</code>将会返回null，什么都不会渲染。</p>
<p><code>render()</code>方法必须是一个纯函数，<strong>他不应该改变<code>state</code></strong>，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>render()</code>不会被调用。</p>
<p><strong>Fragments</strong></p>
<blockquote>
<p>你也可以在render()中使用数组，如：(不要忘记给每个数组元素添加key，防止出现警告)</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return [</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"A"</span>&gt;</span>First item<span class="tag">&lt;/<span class="name">li</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"B"</span>&gt;</span>Second item<span class="tag">&lt;/<span class="name">li</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"C"</span>&gt;</span>Third item<span class="tag">&lt;/<span class="name">li</span>&gt;</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">//换一种写法，可以不写key（v16++）</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>First item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Second item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Third item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.componentDidMount()</strong></p>
<blockquote>
<p>仅在客户端的第一次渲染之后执行(组件真正在被装载之后)。</p>
</blockquote>
<p>这是AJAX请求和DOM或状态更新应该发生的地方。此方法也用于与其他JavaScript框架以及任何延迟执行的函数(如 setTimeout 或 setInterval )进行集成，在这里使用它来更新状态，以便我们可以触发其他生命周期方法。</p>
<p><strong><s>componentWillMount() / UNSAFE_componentWillMount()</s></strong></p>
<blockquote>
<p><code>componentWillMount()</code>将在react未来版本中被弃用。<code>UNSAFE_componentWillMount()</code>在组件挂载前被调用，在这个方法中调用<code>setState()</code>不会起作用，是由于它在<code>render()</code>前被调用。</p>
</blockquote>
<p><strong><em>为了避免副作用和其他的订阅，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。</em></strong></p>
<p><strong>5.shouldComponentUpdate(nextProps, nextState)</strong></p>
<blockquote>
<p>在未来版本，<code>shouldComponentUpdate()</code>将会作为一个提示而不是严格的指令，返回<code>false</code>仍然可能导致组件的重新渲染。官方并不建议在<code>shouldComponentUpdate()</code>中进行深度查询或使用<code>JSON.stringify()</code>，他效率非常低，并且损伤性能。</p>
</blockquote>
<p>调用shouldComponentUpdate使react知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。</p>
<p>在渲染新的<code>props</code>或<code>state</code>前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在<code>forceUpdate()</code>时被调用。返回<code>false</code>不会阻止子组件在<code>state</code>更改时重新渲染。如果shouldComponentUpdate()返回false，<code>componentwillupdate,render和componentDidUpdate</code>不会被调用。</p>
<p><strong><s>componentWillUpdate/UNSAFE_componentWillUpdate(nextProps, nextState)</s></strong></p>
<blockquote>
<p>在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。</p>
</blockquote>
<p>不能在这里使用this.setState()，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedStateFromProps。</p>
<p><strong>6.getSnapshotBeforeUpdate()</strong></p>
<blockquote>
<p>在<code>render()</code>后的输出被渲染到DOM之前被调用。</p>
</blockquote>
<p>它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给<code>componentDidUpdate()</code>。</p>
<p><strong>7.componentDidUpdate(prevProps, prevState, snapshot)</strong></p>
<blockquote>
<p>在更新发生后立即调用<code>componentDidUpdate()</code>。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。</p>
</blockquote>
<p>如果组件实现<code>getSnapshotBeforeUpdate()</code>生命周期，则它返回的值将作为第三个“快照”参数传递给<code>componentDidUpdate()</code>。否则，这个参数是<code>undefined</code>。</p>
<p><strong>8.componentWillUnmount()</strong></p>
<blockquote>
<p>在组件被卸载并销毁之前立即被调用。</p>
</blockquote>
<p>在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在<code>componentDidMount()</code>中创建的任何监听。</p>
<p><strong>9.componentDidCatch(error, info)</strong></p>
<blockquote>
<p>错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。</p>
</blockquote>
<p>如果类组件定义了此生命周期方法，则它将成为错误边界。在它中调用<code>setState()</code>可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复;不要试图将它们用于控制流程。</p>
<p><strong><em>错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。</em></strong></p>
<hr>
<h3 id="React-性能优化是哪个周期函数"><a href="#React-性能优化是哪个周期函数" class="headerlink" title="-React 性能优化是哪个周期函数"></a>-React 性能优化是哪个周期函数</h3><blockquote>
<p>-shouldComponentUpdate是做什么的</p>
</blockquote>
<p><code>shouldComponentUpdate</code> 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<hr>
<h3 id="React中refs的作用是什么"><a href="#React中refs的作用是什么" class="headerlink" title="-React中refs的作用是什么"></a>-React中refs的作用是什么</h3><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span> (<span class="params">&#123;handleSubmit&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputElement</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">'text'</span></span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="如何创建refs"><a href="#如何创建refs" class="headerlink" title="-如何创建refs"></a>-如何创建refs</h3><p>Refs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用 refs ，只需将 ref 分配给构造函数中的实例属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="展示组件和容器组件之间有何不同"><a href="#展示组件和容器组件之间有何不同" class="headerlink" title="-展示组件和容器组件之间有何不同"></a>-展示组件和容器组件之间有何不同</h3><p>展示组件<code>(Presentational component)</code>:展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 <code>UI 状态</code>而不是<code>数据的状态</code>。</p>
<p>容器组件<code>(Container component)</code>:容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 <code>Flux actions</code>，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</p>
<hr>
<h3 id="类组件和函数组件之间有什么区别"><a href="#类组件和函数组件之间有什么区别" class="headerlink" title="-类组件和函数组件之间有什么区别"></a>-类组件和函数组件之间有什么区别</h3><blockquote>
<p>无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props 。所有 React 组件都必须是纯函数，并禁止修改其自身 props 。React是单项数据流，父组件改变了属性，那么子组件视图会更新。</p>
</blockquote>
<p><strong>类组件（ Class components ）</strong><br>属性 props 是外界传递过来的，状态 state 是组件本身的，状态可以在组件中任意修改，组件的属性和状态改变都会更新视图。<br>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Welcome &#123; <span class="keyword">this</span>.props.name &#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Welcome name='react' /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>
<p><strong>函数组件（functional component）</strong><br>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>区别</strong></p>
<p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p>
<p>函数组件，类组件<br>是否有this?没有，有<br>是否有生命周期?没有，有<br>是否有状态state？没有，有</p>
<p><em>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 <code>无状态组件(stateless component)</code>，可以使用一个纯函数来创建这样的组件。这种组件也被称为<code>哑组件dumb components</code>或<code>展示组件(Presentational component)</code></em></p>
<p><strong><em>为了提高性能，尽量使用函数组件。</em></strong></p>
<hr>
<h3 id="组件的状态-state-和属性-props-之间有何不同"><a href="#组件的状态-state-和属性-props-之间有何不同" class="headerlink" title="-组件的状态(state)和属性(props)之间有何不同"></a>-组件的状态(state)和属性(props)之间有何不同</h3><blockquote>
<p><code>state</code> 和 <code>props</code> 都是普通的JavaScript对象。尽管它们两者都具有影响渲染输出的信息，但它们在组件方面的功能不同。</p>
</blockquote>
<p><code>props</code>(properties 的简写)是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性(immutable)，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。<br>组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p>
<p><code>state</code> 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 <code>constructor</code> 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的<code>setState()</code> 来修改，修改 state 属性会导致组件的重新渲染。</p>
<hr>
<h3 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="-何为受控组件(controlled component)"></a>-何为受控组件(controlled component)</h3><p>在 <code>HTML</code> 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。</p>
<p>但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为<code>&quot;受控元素&quot;</code>。</p>
<p><strong>受控组件</strong></p>
<blockquote>
<p>受控组件就是组件的状态受React控制。上面提到过，既然通过设置input的value属性, 无法改变输入框值,那么我们把它和state结合在一起,再绑定onChange事件,实时更新value值就行了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: props.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">        onChange=&#123;e =&gt; <span class="keyword">this</span>.handleChange(e)&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非受控组件</strong></p>
<blockquote>
<p>非受控组件，即组件的状态不受React控制的组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>))</span><br></pre></td></tr></table></figure>
<p>在这个最简单的输入框组件里,我们并没有干涉input中的value展示,即用户输入的内容都会展示在上面。如果我们通过props给组件设置一个初始默认值,<code>defaultValue</code>属性是React内部实现的一个属性,目的类似于input的<code>placeholder</code>属性。</p>
<hr>
<h3 id="在构造函数中调用-super-props-的目的是什么"><a href="#在构造函数中调用-super-props-的目的是什么" class="headerlink" title="-在构造函数中调用 super(props) 的目的是什么"></a>-在构造函数中调用 super(props) 的目的是什么</h3><p>在 <code>super()</code> 被调用之前，子类是不能使用 <code>this</code> 的，在 <code>ES6</code> 中，子类必须在 <code>constructor</code> 中调用 <code>super()</code>。传递 <code>props</code> 给 <code>super()</code> 的原因则是便于(在子类中)能在 <code>constructor</code> 访问 <code>this.props</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用props：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// Prints &#123; name: 'sudheer',age: 30 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用props：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// Prints undefined</span></span><br><span class="line">    <span class="comment">// But Props parameter is still available</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// Prints &#123; name: 'sudheer',age: 30 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// No difference outside constructor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props) <span class="comment">// Prints &#123; name: 'sudheer',age: 30 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码片段揭示了this.props行为仅在构造函数中有所不同,外部构造函数相同。</p>
<hr>
<h3 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="-何为高阶组件(higher order component)"></a>-何为高阶组件(higher order component)</h3><blockquote>
<p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
</blockquote>
<p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。基本上，这是从React的组成性质派生的一种模式，我们称它们为 “纯”组件， 因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件的任何行为。</p>
<p><strong><em>最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</em></strong></p>
<hr>
<h3 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="-除了在构造函数中绑定 this，还有其它方式吗"></a>-除了在构造函数中绑定 this，还有其它方式吗</h3><p>你可以使用属性<code>初始值设定项</code>(property initializers)来正确绑定回调，<code>create-react-app</code> 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>
<hr>
<h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="-应该在 React 组件的何处发起 Ajax 请求"></a>-应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 <code>componentDidMount</code> 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 <code>Ajax</code> 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 <code>componentDidMount</code> 中发起网络请求将保证这有一个组件可以更新了。</p>
<hr>
<h3 id="描述事件在-React-中的处理方式"><a href="#描述事件在-React-中的处理方式" class="headerlink" title="-描述事件在 React 中的处理方式"></a>-描述事件在 React 中的处理方式</h3><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 <code>SyntheticEvent</code> 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p>
<p>这些 <code>SyntheticEvent</code> 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p>
<hr>
<h3 id="createElement-和-cloneElement-有什么区别"><a href="#createElement-和-cloneElement-有什么区别" class="headerlink" title="-createElement 和 cloneElement 有什么区别"></a>-createElement 和 cloneElement 有什么区别</h3><blockquote>
<p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。</p>
</blockquote>
<p>它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="React中有三种构建组件的方式"><a href="#React中有三种构建组件的方式" class="headerlink" title="-React中有三种构建组件的方式"></a>-React中有三种构建组件的方式</h3><p>React.createClass()、ES6 class 和无状态函数。</p>
<hr>
<h3 id="以下使用React-createElement的等价项是什么"><a href="#以下使用React-createElement的等价项是什么" class="headerlink" title="-以下使用React.createElement的等价项是什么"></a>-以下使用React.createElement的等价项是什么</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题：</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/以下等同于什么使用 React.createElement ？</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/答：</span></span><br><span class="line"><span class="regexp">const element = React.createElement(</span></span><br><span class="line"><span class="regexp">  'h1',</span></span><br><span class="line"><span class="regexp">  &#123;className: 'greeting'&#125;,</span></span><br><span class="line"><span class="regexp">  'Hello, world!'</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用React-Hooks有什么优势"><a href="#使用React-Hooks有什么优势" class="headerlink" title="-使用React Hooks有什么优势"></a>-使用React Hooks有什么优势</h3><blockquote>
<p>hooks 是react 16.8 引入的特性，他允许你在不写class的情况下操作state和react的其他特性。</p>
</blockquote>
<p>hooks 只是多了一种写组件的方法，使编写一个组件更简单更方便，同时可以自定义hook把公共的逻辑提取出来，让逻辑在多个组件之间共享。<br>比如你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。</p>
<p><strong><em>ReactHooks的优点 ：无需复杂的DOM结构，简洁易懂</em></strong></p>
<hr>
<h3 id="为什么类方法需要绑定"><a href="#为什么类方法需要绑定" class="headerlink" title="-为什么类方法需要绑定"></a>-为什么类方法需要绑定</h3><p>在JavaScript中， <code>this</code> 的值取决于当前上下文。在React类的组件方法中，开发人员通常希望它引用组件的当前实例，因此有必要 将 这些方法 绑定 到该实例。通常，这是在构造函数中完成的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubmitButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isFormSubmitted: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isFormSubmitted: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="简述-flux-思想"><a href="#简述-flux-思想" class="headerlink" title="-简述 flux 思想"></a>-简述 flux 思想</h3><blockquote>
<p>Flux 的最大特点，就是数据的”单向流动”。有四个组成部分 <code>action</code>，<code>dispatcher</code>，<code>view</code>，<code>store</code></p>
</blockquote>
<p>用户访问 View<br>View 发出用户的 Action<br>Dispatcher 收到 Action，要求 Store 进行相应的更新<br>Store 更新后，发出一个”change”事件<br>View 收到”change”事件后，更新页面</p>
<hr>
<h3 id="简述-redux-思想"><a href="#简述-redux-思想" class="headerlink" title="-简述 redux 思想"></a>-简述 redux 思想</h3><blockquote>
<p>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题。原理是集中式管理，主要有三个核心方法，<code>action</code>，<code>store</code>，<code>reducer</code></p>
</blockquote>
<p><code>view</code> 调用 <code>store</code> 的 <code>dispatch</code> 接收 <code>action</code> 传入 <code>store</code> ，<code>reducer</code> 进行 <code>state</code> 操作，<br><code>view</code> 通过 <code>store</code> 提供的 <code>getState</code> 获取最新的数据，</p>
<p><code>Redux</code> 和 <code>Flux</code> 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 <code>redux</code> 中只能定义一个可更新状态的 <code>store</code>，<code>redux</code> 把 store 和 Dispatcher 合并,结构更加简单清晰。</p>
<p><strong><em>一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们。</em></strong></p>
<hr>
<h3 id="redux-有什么缺点"><a href="#redux-有什么缺点" class="headerlink" title="-redux 有什么缺点"></a>-redux 有什么缺点</h3><p>一个组件所需要的数据，必须由父组件传过来，而不能像 <code>flux</code> 中直接从 <code>store</code> 取。当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 <code>render</code>，可能会有效率影响，或者需要写复杂的 <code>shouldComponentUpdate</code> 进行判断。</p>
<hr>
<h3 id="描述Flux与MVC"><a href="#描述Flux与MVC" class="headerlink" title="-描述Flux与MVC"></a>-描述Flux与MVC</h3><p>传统的MVC模式在分离数据（模型），UI（视图）和逻辑（控制器）的关注方面效果很好，但是MVC架构经常遇到两个主要问题：</p>
<ul>
<li>数据流定义不佳： 跨视图进行的级联更新通常会导致纠结的事件网，难以调试。</li>
<li>缺乏数据完整性： 可以从任何地方对模型数据进行突变，从而在整个UI上产生不可预测的结果。</li>
</ul>
<p>使用Flux模式，复杂的UI不再受到级联更新的困扰。任何给定的React组件都将能够根据商店提供的数据重建其状态。Flux模式还通过限制对共享数据的直接访问来增强数据完整性。</p>
<hr>
<h3 id="React-Context是什么"><a href="#React-Context是什么" class="headerlink" title="-React Context是什么"></a>-React Context是什么</h3><blockquote>
<p>React文档官网并未对 Context 给出“是什么”的定义，更多是描述使用的 Context 的场景，以及如何使用 Context 。</p>
</blockquote>
<p>官网对于使用 Context 的场景是这样描述的：<br><code>In Some Cases, you want to pass data through the component tree without having to pass the props down manuallys at every level. you can do this directly in React with the powerful &quot;context&quot; API.</code></p>
<p><strong>简单说就是，当你不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现 跨层级 的组件数据传递。</strong></p>
<ul>
<li>使用props或者state传递数据，数据自顶下流。<!-- pic1 --></li>
<li>使用 Context ，可以跨越组件进行数据传递。<!-- pic2 -->
</li>
</ul>
<hr>
<h3 id="React-Fiber是什么"><a href="#React-Fiber是什么" class="headerlink" title="-React Fiber是什么"></a>-React Fiber是什么</h3><p>React Fiber 并不是所谓的<code>纤程（微线程、协程）</code>，而是一种基于浏览器的单线程调度算法，背后的支持 API 是大名鼎鼎的：<code>requestIdleCallback</code>。</p>
<p>Fiberl是一种将 <code>Reconciliation</code> （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的<code>一帧</code>（16ms）内，还有没有足够的时间允许计算。</p>
<hr>
<p><br></p>
<p>参考文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/91725031" target="_blank" rel="noopener">高质量React面试题</a></li>
<li><a href="https://segmentfault.com/a/1190000016885832?utm_source=tag-newest" target="_blank" rel="noopener">常见react面试题汇总</a></li>
<li><a href="https://blog.csdn.net/qq_34134278/article/details/81328464" target="_blank" rel="noopener">React组件生命周期概述(16.4)</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        分享就是回顾自己所学的知识，欢迎大家交流~
        
    </div>
    
    <footer>
        <a href="https://www.williamife.com">
            <img src="/img/avatar.jpg" alt="William Cao">
            William Cao
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.williamife.com/2020/05/29/React常见问题汇总/&title=《React常见问题汇总》 — 我的博客&pic=https://www.williamife.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.williamife.com/2020/05/29/React常见问题汇总/&title=《React常见问题汇总》 — 我的博客&source=我叫William，是一名前端工程师，对前端和编程技术非常热爱。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.williamife.com/2020/05/29/React常见问题汇总/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《React常见问题汇总》 — 我的博客&url=https://www.williamife.com/2020/05/29/React常见问题汇总/&via=https://www.williamife.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.williamife.com/2020/05/29/React常见问题汇总/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/11/02/Object.creat/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Object.create</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/02/25/浏览器Timing/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Network 之 Resource Timing字段解析</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷赏赐~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>William Cao &copy; 2018 - 2021</span></p>
        <p> 
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19030143号-1</a>
                
            </span>
            <span>
                
                <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802031297" target="_blank">京公网安备11010802031297号</a><br>
                
                <!-- Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a> -->
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.williamife.com/2020/05/29/React常见问题汇总/&title=《React常见问题汇总》 — 我的博客&pic=https://www.williamife.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.williamife.com/2020/05/29/React常见问题汇总/&title=《React常见问题汇总》 — 我的博客&source=我叫William，是一名前端工程师，对前端和编程技术非常热爱。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.williamife.com/2020/05/29/React常见问题汇总/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《React常见问题汇总》 — 我的博客&url=https://www.williamife.com/2020/05/29/React常见问题汇总/&via=https://www.williamife.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.williamife.com/2020/05/29/React常见问题汇总/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3aQW7DQAgF0N7/0q7UVasqzgecqsFvVpaV2PO8QDDw8RGv42t9v/6+kvu9/168MDAw3pZxnK7fW/n9r3y7vfee/wYDA+M+jCTInj86j4e9T/NkzxgYGBjFZO78fhJ8MTAwMOYBNy9Kq8EXAwMDY1LEJknhteH7JbU4BgbGGzJ6jYG/uX55fwMDA+PfM47WShK16tOOwcLAwNjNSArO18025LAoEGNgYNyGkRel5xut3uk1Rx8GXAwMjKWMasJXHQ6rjly8pL+BgYGxglFN9eYtgd7oxsMiFgMDYx1jEiivajBUBy+iUIuBgbGUkQfc6rFaEmqrTc2HARcDA2MdY1LE5gllzuilkhgYGHdgVBO1vLid1NbNdiYGBsZqRt627B23NbdSnKnAwMDYyrgqXFZHK3pNhdFXxMDAeHNG3gaYJ3C9D1eIxBgYGIsY1dGH8lBp3MjsfYgf/Q0MDIyljF4Ivqox0BtHK4x9YGBgLGLkr58PWCTBurcfDAyMOzCqB2d50pYXpdUxtUK+iYGBsYJRPRqrBuU8+WsewGFgYKxmTAJffgDXO7xrBl8MDIxFjKO4qinj/GAuei8GBsZqRr7mh2vJEyZFNQYGxm7GJMhWU8b8Trm0xsDAuAEjbxhUC9SrYv8THgYGBkbM6B2rVdPKKHvFwMC4JSPf3CRlbLZUMTAwbsDIg+YE0Nt6FHYxMDBWM3qNgeoLkhK3F8oxMDBWMz4BrtX6CM1dVegAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
