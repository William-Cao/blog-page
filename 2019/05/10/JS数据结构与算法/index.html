<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    


<!-- Baidu Push -->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- End Baidu Push -->

    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="21k73v5G8oRoUeP-cTwUyeD5lkZ5asW5K667uxY6oqI">
    
    
    <meta name="baidu-site-verification" content="I1QHrtH1Ea">
    
    
    
    <link rel="canonical" href="https://www.williamife.com//2019/05/10/JS数据结构与算法/">
    
    
    <title>JS中的数据结构和算法 | 我的博客 | What&#39;s past is prologue.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JavaScript,Node.js">
    <meta name="description" content="一、 前言在以往的工作经验中，数据结构和算法对于很多前端工程师来说，一直是可有可无的。但个人觉得，前端工程师其实也是需要重视数据结构和算法的，因为前端所做的东西是用户访问网站第一眼看到的东西，特别在移动浪潮到来之后，对用户体验越来越高，对前端提出了更高的要求，面对越来越复杂的产品，需要坚实的数据结构和算法基础才能驾驭。 如果没有学习过计算机科学的程序员，当我们在处理一些问题时，比较熟悉的数据结构就">
<meta name="keywords" content="JavaScript,Node.js">
<meta property="og:type" content="article">
<meta property="og:title" content="JS中的数据结构和算法">
<meta property="og:url" content="https://www.williamife.com/2019/05/10/JS数据结构与算法/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="一、 前言在以往的工作经验中，数据结构和算法对于很多前端工程师来说，一直是可有可无的。但个人觉得，前端工程师其实也是需要重视数据结构和算法的，因为前端所做的东西是用户访问网站第一眼看到的东西，特别在移动浪潮到来之后，对用户体验越来越高，对前端提出了更高的要求，面对越来越复杂的产品，需要坚实的数据结构和算法基础才能驾驭。 如果没有学习过计算机科学的程序员，当我们在处理一些问题时，比较熟悉的数据结构就">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.williamife.com/img/images/math1.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math2.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math3.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math4.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math5.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math6.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math7.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math8.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math9.png">
<meta property="og:image" content="https://www.williamife.com/img/images/math10.gif">
<meta property="og:image" content="https://www.williamife.com/img/images/math11.gif">
<meta property="og:image" content="https://www.williamife.com/img/images/math12.gif">
<meta property="og:image" content="https://www.williamife.com/img/images/math13.gif">
<meta property="og:updated_time" content="2020-09-09T07:40:28.831Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS中的数据结构和算法">
<meta name="twitter:description" content="一、 前言在以往的工作经验中，数据结构和算法对于很多前端工程师来说，一直是可有可无的。但个人觉得，前端工程师其实也是需要重视数据结构和算法的，因为前端所做的东西是用户访问网站第一眼看到的东西，特别在移动浪潮到来之后，对用户体验越来越高，对前端提出了更高的要求，面对越来越复杂的产品，需要坚实的数据结构和算法基础才能驾驭。 如果没有学习过计算机科学的程序员，当我们在处理一些问题时，比较熟悉的数据结构就">
<meta name="twitter:image" content="https://www.williamife.com/img/images/math1.png">
    
        <link rel="alternate" type="application/atom+xml" title="我的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">William Cao</h5>
          <a href="mailto:demondora@qq.com" title="demondora@qq.com" class="mail">demondora@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5c6664e66fb9a049b41cfdda" target="_blank" >
                <i class="icon icon-lg icon-juejin"></i>
                掘金
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/William-Cao" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.weibo.com/" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JS中的数据结构和算法</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JS中的数据结构和算法</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-05-10T04:20:10.000Z" itemprop="datePublished" class="page-time">
  2019-05-10
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <!-- <h4>TOC</h4> -->
            <h4>文章目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#一、-前言"><span class="post-toc-text">一、 前言</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二、-数据结构"><span class="post-toc-text">二、 数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-列表"><span class="post-toc-text">1. 列表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-栈"><span class="post-toc-text">2. 栈</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-队列"><span class="post-toc-text">3. 队列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-链表"><span class="post-toc-text">4. 链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-字典"><span class="post-toc-text">5. 字典</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-散列"><span class="post-toc-text">6. 散列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-图"><span class="post-toc-text">7. 图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-二叉树"><span class="post-toc-text">8. 二叉树</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#三、-排序算法"><span class="post-toc-text">三、 排序算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#普通排序算法"><span class="post-toc-text">普通排序算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-冒泡排序"><span class="post-toc-text">1. 冒泡排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-选择排序"><span class="post-toc-text">2. 选择排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-插入排序"><span class="post-toc-text">3. 插入排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#高级排序算法"><span class="post-toc-text">高级排序算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-希尔排序"><span class="post-toc-text">4. 希尔排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-归并排序"><span class="post-toc-text">5. 归并排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-快速排序"><span class="post-toc-text">6. 快速排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#四、-查找算法"><span class="post-toc-text">四、 查找算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-顺序查找"><span class="post-toc-text">1. 顺序查找</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-二分查找"><span class="post-toc-text">2. 二分查找</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JS数据结构与算法"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JS中的数据结构和算法</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-05-10 12:20:10" datetime="2019-05-10T04:20:10.000Z"  itemprop="datePublished">2019-05-10</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p>在以往的工作经验中，数据结构和算法对于很多前端工程师来说，一直是可有可无的。但个人觉得，前端工程师其实也是需要重视数据结构和算法的，因为前端所做的东西是用户访问网站第一眼看到的东西，特别在移动浪潮到来之后，对用户体验越来越高，对前端提出了更高的要求，面对越来越复杂的产品，需要坚实的数据结构和算法基础才能驾驭。</p>
<p>如果没有学习过计算机科学的程序员，当我们在处理一些问题时，比较熟悉的数据结构就是数组，数组无疑是一个很好的选择。但很多时候，对于很多复杂的问题，数组就显得太过简陋了，当学习了数据结构和算法之后，对于很多编程问题，当想到一个合适的数据结构后，设计和实现解决这些问题的算法就手到擒来。</p>
<ul>
<li>数据结构：<code>列表、栈、队列、链表、字典、散列、图和二叉查找树</code></li>
<li>排序算法：<code>冒泡排序、选择排序、插入排序、希尔排序、归并排序和快速排序</code></li>
<li>查找算法：<code>顺序查找和二分查找</code></li>
</ul>
<h1 id="二、-数据结构"><a href="#二、-数据结构" class="headerlink" title="二、 数据结构"></a>二、 数据结构</h1><h2 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h2><p>在日常生活中，人们经常使用列表：待办事项列表、购物清单、最佳十名榜单等等。<br>而计算机程序也在使用列表，它是一组<code>有序</code>的数据，每个列表中的数据项称为<code>元素</code>。在JS中，列表中的元素可以是任意数据类型。列表中可以保存多少元素并没有限定（在实际使用时会受到程序内存的限制）。</p>
<p><strong><em>列表的数据结构较为简单，不需要在一个长序列中查找元素，或者对其进行排序。反之，如果数据结构非常复杂，列表的作用就没有那么大了。</em></strong></p>
<p><br></p>
<h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h2><p>栈<code>Stack</code>是一种 <code>LIFO</code> (Last-In-First-Out) 后进先出的数据结构，是一种特殊的列表。想象一下，我们平常在饭馆见到的一摞盘子就是现实世界常见的栈的例子，只能从最上面取盘子，盘子洗干净后，也只能放在最上面。</p>
<p>  <img src="/img/images/math1.png" alt></p>
<p><strong><em>栈是一种高效的数据结构，因为栈内的元素只能通过列表的一端访问，这一端称为栈顶。只要数据的保存满足后入先出或先进后出的原理，都优先考虑使用栈。</em></strong></p>
<p><br></p>
<h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h2><p>队列<code>Queue</code>是典型的 <code>FIFO</code> (First-In-First-Out) 先进先出的数据结构，也是一种特殊的列表，不同的是队列只能在队尾插入元素，在队首删除元素。想象一下，我们在银行排队，排在最前面的人第一个办理业务，而后面来的人只能排在队伍的后面，直到轮到他们为止。</p>
<ul>
<li><p>消息机制可以通过队列来实现，进程调度也是使用队列来实现。</p>
<p><img src="/img/images/math2.png" alt>  </p>
</li>
</ul>
<p><strong><em>只要数据的保存满足先进先出、后入后出的原理，都优先考虑使用队列。</em></strong></p>
<p><br></p>
<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4. 链表"></a>4. 链表</h2><p>链表<code>LinkedList</code>也是一种列表，与其他语言（比如C++和Java）的数组相比，在JavaScript中数组被实现成了对象，数组的索引下标需要在js语言内部转换为js对象的属性名，因此效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。</p>
<ul>
<li><p>单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。<br><img src="/img/images/math3.png" alt>  </p>
</li>
<li><p>双链表以类似的方式工作，但还有一个引用字段，称为“prev”字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。<br><img src="/img/images/math4.png" alt>  </p>
</li>
<li><p>循环链表 和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身。<br><img src="/img/images/math5.png" alt>  </p>
</li>
</ul>
<p><strong><em>在实际应用中，除了有随机访问的需求之外，其他情况都可以用链表替换数组。</em></strong></p>
<p><br></p>
<h2 id="5-字典"><a href="#5-字典" class="headerlink" title="5. 字典"></a>5. 字典</h2><p>字典<code>Dictionary</code>是一种以键-值对存储数据的数据结构，JavaScript中的Object类就是以字典的形式设计的。JavaScript可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能。</p>
<p><strong><em>对象在JavaScript编写中随处可见，所以字典的作用也异常明显了。</em></strong></p>
<p><br></p>
<h2 id="6-散列"><a href="#6-散列" class="headerlink" title="6. 散列"></a>6. 散列</h2><p>散列<code>Hash</code>（也称为哈希表）是一种的常用的数组存储技术，散列后的数组可以快速地插入或取用。散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但对于查找操作来说却效率低下，比如查找一组数组中的最大值和最小值。这些操作需要求助于其他数据结构，比如二叉查找树。</p>
<p>散列表在JavaScript中可以基础数组去进行设计。数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。</p>
<ul>
<li><p>哈希表的关键思想是使用哈希函数将键映射到存储桶</p>
<p><img src="/img/images/math6.png" alt>  </p>
</li>
</ul>
<p>即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法。</p>
<p><strong><em>哈希表可以用于数据的插入、删除和取用，不适用于查找数据。</em></strong></p>
<p><br></p>
<h2 id="7-图"><a href="#7-图" class="headerlink" title="7. 图"></a>7. 图</h2><p>图<code>Graph</code>由边的集合及顶点的集合组成。 顶点代表对象，边则建立起对象之间的关系或关联。<br>如果一个图的顶点对是有序的，则称之为有向图（如流程图），反之，称之为无序图。</p>
<p>  <img src="/img/images/math7.png" alt>  </p>
<ul>
<li>图的存储结构一般为邻接矩阵和邻接表。</li>
<li>搜索图的算法主要有两种：深度优先搜索和广度优先搜索。</li>
</ul>
<p><br></p>
<h2 id="8-二叉树"><a href="#8-二叉树" class="headerlink" title="8. 二叉树"></a>8. 二叉树</h2><p>树<code>Tree</code>一种非线性的数据结构，以分层的方式存储数据。<br>在树结构中，每一个结点只有一个前件，称为父结点，没有前件的结点只有一个，称为树的<code>根结点</code>，简称树的<code>根</code>（root）。每一个结点可以有多个后件，称为该结点的子结点。没有后件的结点称为叶子结点。一个结点所拥有的子结点的个数称为该结点的度，所有结点中最大的度称为树的度。树的最大层次称为树的深度。</p>
<p>二叉树每个节点的子节点不允许超过两个。一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为2，可以写出高效的程序在树中插入、查找和删除数据。<br>  <img src="/img/images/math8.png" alt>  </p>
<p>按照根节点访问的顺序不同，树的遍历分为以下三种：</p>
<ul>
<li>前序遍历：根节点-&gt;左子树-&gt;右子树 <code>ABDEFGC</code></li>
<li>中序遍历：左子树-&gt;根节点-&gt;右子树 <code>DEBGFAC</code></li>
<li>后序遍历：左子树-&gt;右子树-&gt;根节点 <code>EDGFBCA</code></li>
</ul>
<p>二叉查找树<code>BST</code>（Binary Sort Tree）是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。<br>  <img src="/img/images/math9.png" alt>  </p>
<p><strong><em>由于树存储的所有元素之间具有明显的层次特性，因此常被用来存储具有层级关系的数据，比如文件系统中的文件；也会被用来存储有序列表等。</em></strong></p>
<p><br></p>
<h1 id="三、-排序算法"><a href="#三、-排序算法" class="headerlink" title="三、 排序算法"></a>三、 排序算法</h1><h2 id="普通排序算法"><a href="#普通排序算法" class="headerlink" title="普通排序算法"></a>普通排序算法</h2><blockquote>
<p>普通排序算法基本核心思想是指对一组数组按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的for循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。</p>
</blockquote>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (j; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          pos = j</span><br><span class="line">          <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">          arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">          arr[j+<span class="number">1</span>] = temp</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    i = pos</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line">bubbleSort(arr)</span><br><span class="line"><span class="comment">// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>
<p>  <img src="/img/images/math10.gif" alt>  </p>
<p><br></p>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>选择排序 (Selection Sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> minIndex, temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = arr[minIndex]</span><br><span class="line">    arr[minIndex] = arr[i]</span><br><span class="line">    arr[i] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(selectionSort(arr));</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>
<p>  <img src="/img/images/math11.gif" alt>  </p>
<p><br></p>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><p>插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i]</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = key</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(insertSort(arr));</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>
<p>  <img src="/img/images/math12.gif" alt>  </p>
<p><br></p>
<h2 id="高级排序算法"><a href="#高级排序算法" class="headerlink" title="高级排序算法"></a>高级排序算法</h2><blockquote>
<p>高级数据排序算法，通常用于处理大型数据集的最高效排序算法，它们处理的数据集可以达到上百万个元素，而不仅仅是几百个或者几千个，下面我们将介绍希尔排序、归并排序和快速排序。</p>
</blockquote>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>1959年Shell(Shell Sort)发明，第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> temp, gap = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    gap = (gap - <span class="number">1</span>) / <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(shellSort(arr));</span><br><span class="line"><span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>归并排序(Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, middle)</span><br><span class="line">  <span class="keyword">let</span> right = arr.slice(middle)</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">    result.push(left.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">    result.push(right.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr));</span><br></pre></td></tr></table></figure>
<p>  <img src="/img/images/math13.gif" alt><br><br></p>
<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p>快速排序(Quick Sort)是处理大数据集最快的排序算法之一。</p>
<p>它是一种分而治之的算法，通过递归的方法将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤知道所有数据都是有序的。<br>这个算法首先要在列表中选择一个元素作为基准值。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = []</span><br><span class="line">  <span class="keyword">let</span> right = []</span><br><span class="line">  <span class="keyword">let</span> pivot = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> qSort(left).concat(pivot, qSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(qSort(arr));</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="四、-查找算法"><a href="#四、-查找算法" class="headerlink" title="四、 查找算法"></a>四、 查找算法</h1><p>在列表中查找数据有两种方式：<code>顺序查找</code>和<code>二分查找</code>。顺序查找适用于元素随机排列的列表；二分查找适用于元素已排序的列表。二分查找效率更高，但是必须在进行查找之前花费额外的时间将列表中的元素排序。</p>
<h2 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h2><blockquote>
<p>对于查找数据，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判断，直到找到了想要的结果，或者直到列表结尾也没有找到。这种方法称为顺序查找，有时也被称为线性查找。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqSearch</span> (<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === data) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(seqSearch(arr, <span class="number">15</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><blockquote>
<p>二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。</p>
</blockquote>
<p>查找过程可以分为以下步骤：<br>首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。<br>如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。<br>如果某一步数组为空，则表示找不到目标元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binSearch</span> (<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> high = arr.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr[middle] &lt; data) &#123;</span><br><span class="line">      low = middle + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &gt; data) &#123;</span><br><span class="line">      high = middle - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> middle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>];</span><br><span class="line"><span class="built_in">console</span>.log(binSearch(arr, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>参考文章：</p>
<ul>
<li><a href="https://www.2cto.com/kf/201609/548586.html" target="_blank" rel="noopener">十大经典算法总结(Javascript描述)</a></li>
<li><a href="https://www.jianshu.com/u/4d7dd4c7e51d" target="_blank" rel="noopener">JS中的算法与数据结构</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        分享就是回顾自己所学的知识，欢迎大家交流~
        
    </div>
    
    <footer>
        <a href="https://www.williamife.com">
            <img src="/img/avatar.jpg" alt="William Cao">
            William Cao
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.williamife.com/2019/05/10/JS数据结构与算法/&title=《JS中的数据结构和算法》 — 我的博客&pic=https://www.williamife.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.williamife.com/2019/05/10/JS数据结构与算法/&title=《JS中的数据结构和算法》 — 我的博客&source=我叫William，是一名前端工程师，对前端和编程技术非常热爱。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.williamife.com/2019/05/10/JS数据结构与算法/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS中的数据结构和算法》 — 我的博客&url=https://www.williamife.com/2019/05/10/JS数据结构与算法/&via=https://www.williamife.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.williamife.com/2019/05/10/JS数据结构与算法/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/05/29/Mock/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">在项目中使用Mock.js的基本步骤</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/04/29/JS中的原型和原型链/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JS中的原型和原型链</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷赏赐~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>William Cao &copy; 2018 - 2021</span></p>
        <p> 
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19030143号-1</a>
                
            </span>
            <span>
                
                <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802031297" target="_blank">京公网安备11010802031297号</a><br>
                
                <!-- Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a> -->
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.williamife.com/2019/05/10/JS数据结构与算法/&title=《JS中的数据结构和算法》 — 我的博客&pic=https://www.williamife.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.williamife.com/2019/05/10/JS数据结构与算法/&title=《JS中的数据结构和算法》 — 我的博客&source=我叫William，是一名前端工程师，对前端和编程技术非常热爱。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.williamife.com/2019/05/10/JS数据结构与算法/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS中的数据结构和算法》 — 我的博客&url=https://www.williamife.com/2019/05/10/JS数据结构与算法/&via=https://www.williamife.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.williamife.com/2019/05/10/JS数据结构与算法/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3aS27DMAwFwNz/0i7QVYsgzqPofkyNVoFd2xotWFLU4xGP43Oc//565fn6893n95w/e8HAwMC4LeM4HefTXXvbq+VIeC+pGBgYGzDyIJvczQN3cuX8PRgYGBj5J5MEsbpkGBgYGJ1XV9PHvGTFwMDA6BSxyeeT0Ln2l5fV4hgYGDdkXNUY+Inff9DfwMDA+GeMozH6SeR5yC7MBAMDYzQj2ThLCsi8rF1LRqNAjIGBMZqxNsVOO7PKq74HAwNjHiOfRLU90FmUfOEwMDBmM35zWtXyNWk5fKvFMTAwhjLysLvWREw25tZK33IHAwMD47aM/FDFWvlapSaNh5f/NzAwMEYzkqhcnW6neVBNJTEwMGYzOueskpSxWpTmmKidiYGBMYJR6B60k7+1Z6O2AQYGxgaMfKMtD8rVRWkd48DAwNiMkbcM85bn2rOF0IyBgbEZoxour2ptVhuli6khBgbGDRmdJC8Po0lU7HwXAwNjH0bn6ENeAHeanW/uYmBgbMkoF5ONrmmeCL7ZdMPAwBjNOA+7a03Hqw6TRQuKgYExmtGZRDXVy4NsZzMOAwNjEuMojj6gerwjCtkYGBijGZ0kL9/E76R9GBgYGHkLc+2wVz9Ml4tVDAyM0Yxq4MtbCFfF/je1OAYGBkZx0tVn8+bEZQEXAwNjKGNtM65/NDbCYGBgbMDIJ1dtRuYb/a0DFhgYGKMZnb2stXCZLFw1lcTAwBjK+ABm33RyTepLvgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
