{"meta":{"title":"我的博客","subtitle":"What's past is prologue.","description":"我叫William，是一名前端工程师，对前端和编程技术非常热爱。","author":"William Cao","url":"https://www.williamife.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-03-04T07:05:32.000Z","updated":"2019-07-10T05:43:49.585Z","comments":false,"path":"/404.html","permalink":"https://www.williamife.com//404.html","excerpt":"","text":"你所访问的页面不存在！ 资源不存在或者没有访问权限，点击这里 返回主页"},{"title":"About Me~","date":"2019-07-10T05:43:49.596Z","updated":"2019-07-10T05:43:49.596Z","comments":false,"path":"categories/index.html","permalink":"https://www.williamife.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-10T05:43:49.596Z","updated":"2019-07-10T05:43:49.596Z","comments":false,"path":"tags/index.html","permalink":"https://www.williamife.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常见的前端架构风格和案例","slug":"常见的前端架构风格和案例","date":"2021-03-19T15:00:00.000Z","updated":"2021-03-19T16:03:37.486Z","comments":true,"path":"2021/03/19/常见的前端架构风格和案例/","link":"","permalink":"https://www.williamife.com/2021/03/19/常见的前端架构风格和案例/","excerpt":"","text":"所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式。架构风格定义一个词汇表和一组约束，词汇表中包含一些组件及连接器，约束则指出系统如何将构建和连接器组合起来。软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将系统中的各个模块和子系统有机的结合为一个完整的系统。 透过现象看本质，我们来探讨下前端领域一些流行技术栈背后的架构思想。 一、分层风格 分层架构是最常见的软件架构，你要不知道用什么架构，或者不知道怎么解决问题，那就尝试加多一层。一个分层系统是按照层次来组织的，每一层为在其之上的层提供服务，并且使用在其之下的层所提供的服务。 分层通常可以解决什么问题？ 是隔离业务复杂度与技术复杂度的利器。 典型的例子是网络协议, 越高层越面向人类，越底层越面向机器。一层一层往上，很多技术的细节都被隐藏了，比如我们使用HTTP时，不需要考虑TCP的握手和包传输细节，TCP不需要关心IP的寻址和路由。 分离关注点和复用。减少跨越多层的耦合, 当一层变动时不会影响到其他层。 例如我们前端项目建议拆分逻辑层和视图层，一方面可以降低逻辑和视图之间的耦合，当视图层元素变动时可以尽量减少对逻辑层的影响；另外一个好处是, 当逻辑抽取出去后，可以被不同平台的视图复用。 关注点分离之后，软件的结构会变得容易理解和开发, 每一层可以被复用, 容易被测试, 其他层的接口通过模拟解决. 但是分层架构，也不是全是优点，分层的抽象可能会丢失部分效率和灵活性, 比如编程语言就有所谓的层次，语言抽象的层次越高，运行效率会相应衰减: Virtual DOM前端石器时代，我们页面交互和渲染，是通过服务端渲染或者直接操作DOM实现的. 123456$('.tab-list').on('click','.tab',function(e)&#123; e.preventDefault() $('.tab').removeClass('active') $('.tab-content').removeClass('active') $(this).addClass('active')&#125;) 由于SPA类型项目的出现，DOM tree的结构变得越来越复杂，它的改变也变得越来越频繁，大量的DOM操作产生了，对DOM节点的增删改，还有许多的事件监听、事件回调、事件销毁需要处理。由于DOM tree结构的频繁变化，会导致大量的reflow从而影响性能。 然后React就搞了一层VirtualDOM。 所谓的VirtualDOM，也就是虚拟节点。它通过 JS 的 Object 对象模拟 DOM 中的节点，然后再通过特定的 render 方法将其渲染成真实的 DOM 节点。 所以说 VirtualDOM 更大的意义在于开发方式的转变: 声明式、数据驱动, 让开发者不需要关心 DOM 的操作细节 (属性操作、事件绑定、DOM 节点变更) ，另外有了VirtualDOM这一层抽象层，使得多平台渲染成为可能。 当然VirtualDOM或者React，不是唯一一个这样的解决方案。其他前端框架，例如Vue、Angular基本都是这样一个发展历程。我们通过RN可以开发跨平台的移动应用，但是众所周知，它运行效率或者灵活性暂时是无法与原生应用比拟的。 多端统一开发框架chameleon、Taro、uni-app、mpvue、WePY 软件架构设计里面最基础的概念“拆分”和“合并”，拆分的意义是“分而治之”，将复杂问题拆分成单一问题解决，比如后端业务系统的”微服务化“设计；“合并”的意义是将同样的业务需求抽象收敛到一块，达成高效率高质量的目的，例如后端业务系统中的“中台服务”设计。 现如今市面上端的形态多种多样，Web、App 端(React Native)、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 多端统一开发框架属于后者，通过定义统一的语言框架 + 统一多态协议，从多端（对应多个独立服务）业务中抽离出自成体系、连续性强、可维护强的“前端中台服务”。 chameleon Taro 二、管道/过滤器在管道/过滤器架构风格中，每个组件都有一组输入和输出，每个组件职责都很单一，数据输入组件，经过内部处理，然后将处理过的数据输出。所以这些组件也称为过滤器，连接器按照业务需求将组件连接起来，其形状就像管道一样，这种架构风格由此得名。 Unix管道 在\\unix中经常会看到stdin，stdout和stderr，这3个可以称为终端（Terminal）的标准输入（standard input），标准输出（ standard out）和标准错误输出（standard error）。* 这里面最经典的案例是Unix Shell命令，Unix的哲学之一就是“让程序只做好一件事”，所以我们常用的Unix命令功能都非常单一，但是Unix Shell还有一件法宝就是管道，通过管道我们可以将命令通过标准输入输出串联起来实现复杂的功能: 12345678# 获取网页，并进行拼写检查。代码来源于wikicurl \"http://en.wikipedia.org/wiki/Pipeline_(Unix)\" | \\sed 's/[^a-zA-Z ]/ /g' | \\tr 'A-Z ' 'a-z\\n' | \\grep '[a-z]' | \\sort -u | \\comm -23 - /usr/share/dict/words | \\less ReactiveX另一个和Unix管道相似的例子是ReactiveX, 例如RxJS。很多教程将Rx比喻成河流，这个河流的开头就是一个事件源，这个事件源按照一定的频率发布事件。Rx真正强大的其实是它的操作符，有了这些操作符，你可以对这条河流做一切可以做的事情，例如分流、节流、建大坝、转换、统计、合并、产生河流的河流… 这些操作符和Unix的命令一样，职责都很单一，只干好一件事情。但我们管道将它们组合起来的时候，就迸发了无限的能力. 12345678910import &#123; fromEvent &#125; from 'rxjs';import &#123; throttleTime, map, scan &#125; from 'rxjs/operators';fromEvent(document, 'click') .pipe( throttleTime(1000), map(event =&gt; event.clientX), scan((count, clientX) =&gt; count + clientX, 0) ) .subscribe(count =&gt; console.log(count)); Gulp除了上述的RxJS，管道模式在前端领域也有很多应用，主要集中在前端工程化领域。例如’老牌’的项目构建工具Gulp, Gulp使用管道化模式来处理各种文件类型，管道中的每一个步骤称为Transpiler(转译器), 它们以 NodeJS的Stream作为输入输出。整个过程高效而简单。 gulpfile.js123456789101112131415161718192021222324252627282930//gulpfile.jsconst &#123; src, dest, parallel &#125; = require('gulp');const pug = require('gulp-pug');const less = require('gulp-less');const minifyCSS = require('gulp-csso');const concat = require('gulp-concat');function html() &#123; return src('client/templates/*.pug') .pipe(pug()) .pipe(dest('build/html'))&#125;function css() &#123; return src('client/templates/*.less') .pipe(less()) .pipe(minifyCSS()) .pipe(dest('build/css'))&#125;function js() &#123; return src('client/javascript/*.js', &#123; sourcemaps: true &#125;) .pipe(concat('app.min.js')) .pipe(dest('build/js', &#123; sourcemaps: true &#125;))&#125;exports.js = js;exports.css = css;exports.html = html;exports.default = parallel(html, css, js); 不确定是否受到Gulp的影响，现代的Webpack打包工具，也使用同样的模式来实现对文件的处理，即Loader，Loader 用于对模块的源代码进行转换，通过Loader的组合，可以实现复杂的文件转译需求。 webpack.config.js12345678910111213141516// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\\.scss$/, use: [&#123; loader: \"style-loader\" // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: \"css-loader\" // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: \"sass-loader\" // 将 Sass 编译成 CSS &#125;] &#125;] &#125;&#125;; 管道中间件 中间件(middleware)就是一个函数，用来完成各种特定的任务。它最大的特点就是，一个中间件处理完，可以把相应数据再传递给下一个中间件。 如果开发过Express、Koa或者Redux， 你可能会发现中间件模式和上述的管道模式有一定的相似性。 Koa2的洋葱圈模型，如下图。 洋葱圈模型有以下特点: 中间件没有显式的输入输出 这些中间件之间通常通过集中式的上下文对象来共享状态 有一个循环的过程 管道中，数据处理完毕后交给下游了，后面就不管了。而中间件还有一个回归的过程，当下游处理完毕后会进行回溯，所以有机会干预下游的处理结果。 我们暂且把它当作一个特殊形式的管道模式吧。这种模式通常用于后端，它可以干净地分离出请求的不同阶段，也就是分离关注点。比如我们可以创建这些中间件： 日志： 记录开始时间，计算响应时间，输出请求日志 认证： 验证用户是否登录 授权： 验证用户是否有执行该操作的权限 缓存： 是否有缓存结果，有的话就直接返回，当下游响应完成后，再判断一下响应是否可以被缓存 执行： 执行实际的请求处理、响应 这个简易的 gif 说明了 async 函数如何使我们能够恰当地利用堆栈流来实现请求和响应流： koa2洋葱模型源码分析 三、事件驱动 事件驱动编程最好的方法论是发布订阅模式，对于前端开发来说是再熟悉不过的概念了。 它定义了一种一对多的依赖关系， 在事件驱动系统风格中，组件不直接调用另一个组件，而是触发或广播一个或多个事件。系统中的其他组件在一个或多个事件中注册。当一个事件被触发，系统会自动通知在这个事件中注册的所有组件。 这样就分离了关注点，订阅者依赖于事件而不是依赖于发布者，发布者也不需要关心订阅者，两者解除了耦合。生活中也有很多发布-订阅的例子，比如微信公众号信息订阅，当新增一个订阅者的时候，发布者并不需要作出任何调整，同样发布者调整的时候也不会影响到订阅者，只要协议没有变化。我们可以发现，发布者和订阅者之间其实是一种弱化的动态的关联关系。 解除耦合目的是一方面, 另一方面也可能由基因决定的，一些事情天然就不适合或不支持用同步的方式去调用，或者这些行为是异步触发的。 Node.js事件驱动模型 Application应用层，即JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs等 V8这一层是V8引擎层，这一层的主要作用是解析JavaScript，同时和应用层和NodeApi层交互 NodeApi为上层模块提供系统调用，和操作系统进行交互 。 Libuv是跨平台的底层封装，实现了线程池、事件循环、文件操作等，是 Node.js 实现异步的核心。 libuv是一个高性能事件驱动库，屏蔽了各种操作系统的差异从而提供了统一的API。libuv严格使用异步、事件驱动的编程风格。其核心工作是提供事件循环及 基于I/O 或其他活动事件的回调机制。libuv库包含了诸如计时器、非阻塞网络支持、异步文件系统访问、线程创建、子进程等核心工具。 I/O模型、Libuv和Eventloop 四、复制风格 基于复制(Replication)风格的系统，会利用多个实例提供相同的服务，来改善服务的可访问性和可伸缩性，以及性能。这种架构风格可以改善用户可察觉的性能，简单服务响应的延迟。 这种风格在后端用得比较多，举前端比较熟悉的例子，NodeJS是单线程的，为了利用多核资源，NodeJS标准库提供了一个cluster模块，它可以根据CPU数创建多个Worker进程，这些Worker进程可以共享一个服务器端口，对外提供同质的服务, Master进程会根据一定的策略将资源分配给Worker: 12345678910111213141516171819202122232425const cluster = require('cluster');const http = require('http');const numCPUs = require('os').cpus().length;if (cluster.isMaster) &#123; console.log(`Master $&#123;process.pid&#125; is running`); // Fork workers. for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`worker $&#123;worker.process.pid&#125; died`); &#125;);&#125; else &#123; // Workers可以共享任意的TCP连接 // 比如共享HTTP服务器 http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end('hello world\\n'); &#125;).listen(8000); console.log(`Worker $&#123;process.pid&#125; started`);&#125; 利用多核能力可以提升应用的性能和可靠性。我们也可以利用PM2这样的进程管理工具，来简化Node集群的管理，它支持很多有用的特性，例如集群节点重启、日志归集、性能监视等。 复制风格常用于网络服务器。浏览器和Node都有Worker的概念，但是一般都只推荐在CPU密集型的场景使用它们，因为浏览器或者NodeJS内置的异步操作已经非常高效。实际上前端应用CPU密集型场景并不多，或者目前阶段不是特别实用。除此之外你还要权衡进程间通信的效率、Worker管理复杂度、异常处理等事情。 有一个典型的CPU密集型的场景，即源文件转译。典型的例子是CodeSandbox, 它就是利用浏览器的Worker机制来提高源文件的转译性能的: 除了处理CPU密集型任务，对于浏览器来说，Worker也是一个重要的安全机制，用于隔离不安全代码的执行，或者限制访问浏览器DOM相关的东西。 五、微内核架构 微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。 内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。微内核结构的难点在于建立一套粒度合适的插件协议、以及对插件之间进行适当的隔离和解耦。从而才能保证良好的扩展性、灵活性和可迁移性。 前端领域比较典型的例子是Webpack、Babel、PostCSS以及ESLint, 这些应用需要应对复杂的定制需求，而且这些需求时刻在变，只有微内核架构才能保证灵活和可扩展性。 WebpackWebpack的核心是一个Compiler，这个Compiler主要功能是集成插件系统、维护模块对象图, 对于模块代码具体编译工作、模块的打包、优化、分析、聚合统统都是基于外部插件完成的.如上文说的Loader运用了管道模式，负责对源文件进行转译；那Plugin则可以将行为注入到Compiler运行的整个生命周期的钩子中, 完全访问Compiler的当前状态。 这里还有一篇文章微内核架构应用研究专门写了前端微内核架构模式的一些应用，推荐阅读一下。 六、微前端 微前端旨在将单体前端分解成更小、更简单的模块，这些模块可以被独立的团队进行开发、测试和部署，最后再组合成一个大型的整体。 微前端下各个应用模块是独立运行、独立开发、独立部署的，相对应的会配备更加自治的团队(一个团队干好一件事情)。微前端的实施还需要有稳固的前端基础设施和研发体系的支撑。如果你想深入学习微前端架构，建议阅读Phodal的相关文章，还有他的书《前端架构：从入门到微前端》。 七、组件化 在给定的软件系统中，基于组件的架构侧重于对广泛使用的功能进行关注点分离。即将不同的复杂性、关注点分离出来，分别进行处理，让每一小部分都拥有自己的关注焦点。通过定义、实现松散耦合的独立组件，将其组合到系统中，以降低整个系统的复杂度。 组件化具有一系列的优点：可重用、代码简洁、易测试等。 组件的发展过程： 风格指南(Style Guide)对设计的文字、颜色、LOGO、ICON等设计做出规范，产出物一般为Guidline，Guidline一般为UI的规范。 模式库(Pattern Library)即UI组件库。模式库更侧重于前端开发，对界面元素的样式进行实现，其代码可供预览使用，产出物一般为组件库UI框架等，如Bootstrap库。 设计系统(Design System)设计系统在某种程度上结合了风格指南和模式库，并附加了一些业务特定的元素，并且进一步完善了组件化到页面模板相关的内容。 架构设计：组件化架构 八、其他 还有很多架构风格且这些风格主要应用于后端领域，这里就不一一阐述了。你可以通过扩展阅读了解这些模式 面向对象风格:将应用或系统任务分割为单独、可复用、可自给的对象，每个对象都包含数据、以及对象相关的行为 C/S:客户端/服务器风格 面向服务架构(SOA):指那些利用契约和消息将功能暴露为服务、消费功能服务的应用 N层/三层:和分层架构差不多，侧重物理层. 例如C/S风格就是一个典型的N层架构 点对点风格 微服务架构 云架构 通过上文，你估计会觉得架构风格比设计模式或者算法好理解多的，正所谓大道至简，但是简洁而不简单！大部分项目的架构不是一开始就是这样的，它们可能经过长期的迭代，踩着巨人的肩膀，一路走过来才成为今天的样子。 希望本文可以给你一点启发，对于我们前端工程师来说，不应该只追求能做多酷的页面、掌握多少API，要学会通过现象看本质，举一反三融会贯通，这才是进阶之道。 参考文章： 透过现象看本质: 常见的前端架构风格和案例 架构设计：微前端架构 深入理解 Redux 中间件 五种常见软件架构","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.williamife.com/tags/前端/"}]},{"title":"Object.create","slug":"Object.creat","date":"2020-11-02T09:15:00.000Z","updated":"2020-11-03T05:58:43.298Z","comments":true,"path":"2020/11/02/Object.creat/","link":"","permalink":"https://www.williamife.com/2020/11/02/Object.creat/","excerpt":"","text":"语法：Object.create(proto, [propertiesObject])方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 参数：proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是null， 对象， 函数的prototype属性 （创建空的对象时需传null , 否则会抛出TypeError异常）。propertiesObject : 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 3.返回值：在指定原型对象上添加新属性后的对象。 案例说明： 1）创建对象的方式不同 new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。Object.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。 12345678910111213// new Object() 方式创建var a = &#123; rep : 'apple' &#125;var b = new Object(a)console.log(b) // &#123;rep: \"apple\"&#125;console.log(b.__proto__) // &#123;&#125;console.log(b.rep) // &#123;rep: \"apple\"&#125;// Object.create() 方式创建var a = &#123; rep: 'apple' &#125;var b = Object.create(a)console.log(b) // &#123;&#125;console.log(b.__proto__) // &#123;rep: \"apple\"&#125;console.log(b.rep) // &#123;rep: \"apple\"&#125; Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: “apple”} ,此时这个值不是吧b自身的，是它通过原型链proto来访问到b的值。 2）创建对象属性的性质不同 12345678910111213141516// 创建一个以另一个空对象为原型,且拥有一个属性p的对象o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:o.p = 24o.p//42o.q = 12for (var prop in o) &#123; console.log(prop)&#125;//\"q\"delete o.p//false Object.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。看下图解析： 3）创建空对象时不同 当用构造函数或对象字面量方法创建空对象时，对象时有原型属性的，即有proto;当用Object.create()方法创建空对象时，对象是没有原型属性的。 4）proto 属性JavaScript 的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前只有浏览器环境必须部署有这个属性，其他运行环境不一定要部署，因此不建议使用这个属性，而是使用下面这些来 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 Object.create()描述：该方法创建一个新对象，使用现有的对象来提供新创建的对象的proto；格式：Object.create(proto[, propertiesObject])用法：如果用传统的方法要给一个对象的原型上添加属性和方法，是通过 propt 实现的 123456var proto = &#123; y: 20, z: 40, showNum()&#123;&#125;&#125;;var o = Object.create(proto); 如果是不用Object,create()方法，我们是如何给对象原型添加属性和方法的？—— 通过构造函数或者类，例如： 1234567//创建一个构造函数或者类var People = function()&#123;&#125;People.prototype.y = 20People.prototype.showNum = function() &#123;&#125;//通过构造函数创建实例var p = new People();console.log(p.__proto__ === People.prototype) // true 现在有 Object.create() 就简单的多了 Object.setPrototypeOf描述：该方法的作用与 proto 相同，用来设置一个对象的 prototype 对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。格式：Object.setPrototypeOf(object, prototype)用法：var proto = { y: 20, z: 40};var o = { x: 10 };Object.setPrototypeOf(o, proto); 输出结果中看出，添加的方法是在原型上的。就类似于 obj.proto = proto; Object.getPrototypeOf()描述：用于读取一个对象的原型对象；格式：Object.getPrototypeOf(obj);用法：Object.getPrototypeOf(‘foo’) === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true 4.1）原型属性的继承这里结合一个例子来说说这几个方法的使用：场景：拷贝一个构造函数的实例。 var triangle = {a: 1, b: 2, c: 3}; function ColoredTriangle() { this.color = ‘red’;} //ColoredTriangle.prototype = triangle; //ColoredTriangle.prototype.constructor === ColoredTriangle// falseObject.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true var c = new ColoredTriangle();打印出 实例c 看看结构是怎样的 其中 color 属性在实例上，而其他的原型上。现在来拷贝一个 实例 c2 var c2 = Object.assign({},c)console.log(c2.color); //redconsole.log(c2.a); //undefined因为 Object.assing 是不能拷贝到继承或原型上的方法的。所以 实例c2 没有 a 这个属性。那要怎么要才能拷贝到原型上的方法呢？ 4.1.1）第一种方法 var originProto = Object.getPrototypeOf(c);var originProto2 = Object.create(originProto);var c2 = Object.assign(originProto2, c);//var c2 = Object.assign(Object.create(Object.getPrototypeOf(c)), c) console.log(c2.color); // redconsole.log(c2.a); // 1这样就实现了原型属性的拷贝。Object.getPrototypeOf(c) 既 originProto 得到的是原型上的 //{a: 1, b: 2, c: 3}；Object.create(originProto) 既 originProto2 既是创建了一个 {a: 1, b: 2, c: 3} 在原型上的新对象；Object.assign(originProto2, c) 在源对象originProto2 上合并对象 c； 4.1.2）第二种方法 （推荐） var c = new ColoredTriangle();var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c)); console.log(c2.color); // redconsole.log(c2.a); // 1可以把Object.create()的参数理解为：第一个参数是放在新对象的原型上的，第二个参数是放在新对象的实例上的。所以上面例子Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。 为什么说推荐这个方法呢？因为Object.assign() 方法不能正确拷贝 get ，set 属性。 例如，我们给 c 实例添加一个 “colorGet” 属性，并设置该属性的get 描述符： var c = new ColoredTriangle();Object.defineProperty(c,’colorGet’, { enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性 get(){ return “Could it return “ + this.color }}); var c3 = Object.assign(Object.create(Object.getPrototypeOf(c)), c)结果如下： 这里没有拷贝到 “colorGet” 的 get 描述符，而是直接把获取到的值赋值给 “colorGet” 。 那对于 get 描述符要怎么获取呢？ Object.getOwnPropertyDescriptors就专为解决这问题而生。而又因为要拷贝原型上的属性，所以结合Object.create、Object.getPrototypeOf 方法一起使用。即上面的第二种实现方法，如下： var c = new ColoredTriangle();Object.defineProperty(c,’colorGet’, { enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性 get(){ return “Could it return “ + this.color }}); var c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));结果如下： 此时已经成功的拷贝到了get描述符啦。虽然说实际开发上很少会要去修改 get 描述符，但是知道多一种方法，遇到这种情况时就知道该怎么去解决了。 注意：这些都只是一个层级的深拷贝。 上面实现 原型属性拷贝 中的两种方法中用到了 Object.getOwnPropertyDescriptors 、Object.assing() 、Object.create、Object.getPrototypeOf()方法，通常这几种方法都有一起结合使用。如果上面的例子还不理解，这里把他简单的拿到 对象的继承 来讲解。理解的话就可以忽略啦。 4.2）原型属性的继承以前，继承另一个对象，常常写成下面这样。 const obj = { proto: prot, foo: 123,};ES6 规定proto只有浏览器要部署，其他环境不用部署。如果去除proto，可以用 Object.create() 和 Object.assign() 来实现。 //现在可以这样写 方法1const obj = Object.create(prot);obj.foo = 123; // 或者 方法2const obj = Object.assign( Object.create(prot), { foo: 123, }); // 或者 方法3const obj = Object.create(prot,Object.getOwnPropertyDescriptors({ foo: 123 }));但是 Object.assign() 无法正确拷贝get属性和set属性的问题。例如： var prot = {x: 1, y: 2}var obj = { proto: prot, foo: 100, bar(){ return this.foo}, get baz() {return this.foo}}; var obj2 = Object.assign(Object.create(prot), obj) 上图中，obj 对象的 foo 属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值赋上去。 而 Object.getOwnPropertyDescriptors() 可以解决这个问题 实现get 、set 属性的正确拷贝，即方法3 ，如下： var prot = {x: 1, y: 2}var obj = { proto: prot, foo: 100, bar(){ return this.foo}, get baz() {return this.foo}}; var obj2 = Object.create(prot, Object.getOwnPropertyDescriptors(obj)) 说了那么多种拷贝方法，怎么去选择呢，还是要看实际应用中的情况: 如果只是拷贝 自身可枚举属性，就可以只用 Object.assign 方法；如果是要拷贝原型上的属性，就需要 Object.assign , Object.create, Object.getPrototypeOf 方法结合使用如果是拷贝get /set 属性，就需要 结合 Ojbect.getOwnPropertyDescriptors 方法","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"React常见问题汇总","slug":"React常见问题汇总","date":"2020-05-29T06:05:00.000Z","updated":"2020-10-13T09:56:42.105Z","comments":true,"path":"2020/05/29/React常见问题汇总/","link":"","permalink":"https://www.williamife.com/2020/05/29/React常见问题汇总/","excerpt":"","text":"-什么是JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。 12345678910class MyComponent extends React.Component &#123; render() &#123; let props = this.props; return ( &lt;div className=\"my-component\"&gt; &lt;a href=&#123;props.url&#125;&gt;&#123;props.name&#125;&lt;/a&gt; &lt;/div&gt; ); &#125;&#125; 优点：1.允许使用熟悉的语法来定义 HTML 元素树；2.提供更加语义化且移动的标签；3.程序结构更容易被直观化；4.抽象了 React Element 的创建过程；5.可以随时掌控 HTML 标签以及生成这些标签的代码；6.是原生的 JavaScript。 -什么是虚拟DOM虚拟DOM（VDOM）它是真实DOM的内存表示,一种编程概念，一种模式。它会和真实的DOM同步，比如通过ReactDOM这种库，这个同步的过程叫做调和(Reconciliation)。虚拟DOM更多是一种模式，不是一种特定的技术。 -为什么虚拟DOM会提高性能虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。 -React diff原理把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的 key 属性，方便比较。React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 -React中key的作用是什么Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 123456789render () &#123; return ( &lt;ul&gt; &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 -为什么不直接更新state状态如果进行如下方式更新状态，那么它将不会重新渲染组件。 12//WrongThis.state.message =”Hello world”; 而是使用 setState() 方法。它计划对组件状态对象的更新。状态改变时，组件通过重新渲染做出响应 12//CorrectThis.setState(&#123;message: ‘Hello World’&#125;); 注意：可以分配状态的唯一位置是构造函数。 -调用setState之后发生了什么在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 -为什么建议传递给setState的参数是一个callback为什么建议传递给setState的参数是一个callback而不是一个对象?因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个state。 -React生命周期函数(v16.4) 1.constructor(props) react组件的构造函数在挂载之前被调用。在实现React.Component构造函数时，需要先在添加其他内容前，调用super(props)，用来将父组件传来的props绑定到这个类中，使用this.props将会得到。 官方建议：不要在constructor引入任何具有副作用和订阅功能的代码，这些应当在componentDidMount()中写入。 constructor中应当做些初始化的动作，如：初始化state，将事件处理函数绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。 当然也可以利用props初始化state，在之后修改state不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用redux统一进行状态管理。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; 2.static getDerivedStateFromProps(nextProps, prevState) getDerivedStateFromProps在组件实例化后，和接受新的props后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。 如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。调用setState()不会触发getDerivedStateFromProps()。 1234567891011121314constructor(props) &#123; super(props); this.state = &#123; list: [], &#125; &#125;static getDerivedStateFromProps(nextProps, prevState) &#123; console.log('up',props, state.list) if (state.list.length === 0) &#123; console.log('down',props.list, state.list) return &#123;list : props.list&#125;; //props.list &#125; return null;&#125; componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps) 官方建议使用getDerivedStateFromProps函数代替componentWillReceiveProps()。当组件挂载后，接收到新的props后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用this.setState()。 如果父组件会让这个组件重新渲染，即使props没有改变，也会调用这个方法。react不会在组件初始化props时调用这个方法。调用this.setState也不会触发。 3.render() render()方法是必需的。当他被调用时，他将计算this.props和this.state，并返回以下一种类型： React元素通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。 字符串或数字他们将会以文本节点形式渲染到dom中。 Portalsreact16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。 什么也不渲染 布尔值 也是什么都不渲染，通常后跟组件进行判断。 当返回,false,ReactDOM.findDOMNode(this)将会返回null，什么都不会渲染。 render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果shouldComponentUpdate()返回false，render()不会被调用。 Fragments 你也可以在render()中使用数组，如：(不要忘记给每个数组元素添加key，防止出现警告) 123456789101112131415161718render() &#123; return [ &lt;li key=\"A\"&gt;First item&lt;/li&gt;, &lt;li key=\"B\"&gt;Second item&lt;/li&gt;, &lt;li key=\"C\"&gt;Third item&lt;/li&gt;, ];//换一种写法，可以不写key（v16++）render() &#123; return ( &lt;React.Fragment&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;/React.Fragment&gt; );&#125; 4.componentDidMount() 仅在客户端的第一次渲染之后执行(组件真正在被装载之后)。 这是AJAX请求和DOM或状态更新应该发生的地方。此方法也用于与其他JavaScript框架以及任何延迟执行的函数(如 setTimeout 或 setInterval )进行集成，在这里使用它来更新状态，以便我们可以触发其他生命周期方法。 componentWillMount() / UNSAFE_componentWillMount() componentWillMount()将在react未来版本中被弃用。UNSAFE_componentWillMount()在组件挂载前被调用，在这个方法中调用setState()不会起作用，是由于它在render()前被调用。 为了避免副作用和其他的订阅，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。 5.shouldComponentUpdate(nextProps, nextState) 在未来版本，shouldComponentUpdate()将会作为一个提示而不是严格的指令，返回false仍然可能导致组件的重新渲染。官方并不建议在shouldComponentUpdate()中进行深度查询或使用JSON.stringify()，他效率非常低，并且损伤性能。 调用shouldComponentUpdate使react知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。 在渲染新的props或state前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在forceUpdate()时被调用。返回false不会阻止子组件在state更改时重新渲染。如果shouldComponentUpdate()返回false，componentwillupdate,render和componentDidUpdate不会被调用。 componentWillUpdate/UNSAFE_componentWillUpdate(nextProps, nextState) 在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。 不能在这里使用this.setState()，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedStateFromProps。 6.getSnapshotBeforeUpdate() 在render()后的输出被渲染到DOM之前被调用。 它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate()。 7.componentDidUpdate(prevProps, prevState, snapshot) 在更新发生后立即调用componentDidUpdate()。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。 如果组件实现getSnapshotBeforeUpdate()生命周期，则它返回的值将作为第三个“快照”参数传递给componentDidUpdate()。否则，这个参数是undefined。 8.componentWillUnmount() 在组件被卸载并销毁之前立即被调用。 在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount()中创建的任何监听。 9.componentDidCatch(error, info) 错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。 如果类组件定义了此生命周期方法，则它将成为错误边界。在它中调用setState()可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复;不要试图将它们用于控制流程。 错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。 -React 性能优化是哪个周期函数 -shouldComponentUpdate是做什么的 shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 -React中refs的作用是什么Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回： 123456789101112131415class CustomForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(\"Input Value: \", this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type='text' ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type='submit'&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值： 1234567891011function CustomForm (&#123;handleSubmit&#125;) &#123; let inputElement return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type='text' ref=&#123;(input) =&gt; inputElement = input&#125; /&gt; &lt;button type='submit'&gt;Submit&lt;/button&gt; &lt;/form&gt; )&#125; -如何创建refsRefs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用 refs ，只需将 ref 分配给构造函数中的实例属性 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; -展示组件和容器组件之间有何不同展示组件(Presentational component):展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。 容器组件(Container component):容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。 -类组件和函数组件之间有什么区别 无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props 。所有 React 组件都必须是纯函数，并禁止修改其自身 props 。React是单项数据流，父组件改变了属性，那么子组件视图会更新。 类组件（ Class components ）属性 props 是外界传递过来的，状态 state 是组件本身的，状态可以在组件中任意修改，组件的属性和状态改变都会更新视图。类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态。 123456789class Welcome extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Welcome &#123; this.props.name &#125;&lt;/h1&gt; ); &#125;&#125;ReactDOM.render(&lt;Welcome name='react' /&gt;, document.getElementById('root')); 函数组件（functional component）该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"Sara\" /&gt;;ReactDOM.render( element, document.getElementById('root')); 区别 函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。 函数组件，类组件是否有this?没有，有是否有生命周期?没有，有是否有状态state？没有，有 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 无状态组件(stateless component)，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件dumb components或展示组件(Presentational component) 为了提高性能，尽量使用函数组件。 -组件的状态(state)和属性(props)之间有何不同 state 和 props 都是普通的JavaScript对象。尽管它们两者都具有影响渲染输出的信息，但它们在组件方面的功能不同。 props(properties 的简写)是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性(immutable)，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。 state 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的setState() 来修改，修改 state 属性会导致组件的重新渲染。 -何为受控组件(controlled component)在 HTML 中，类似 &lt;input&gt;, &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。 但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为&quot;受控元素&quot;。 受控组件 受控组件就是组件的状态受React控制。上面提到过，既然通过设置input的value属性, 无法改变输入框值,那么我们把它和state结合在一起,再绑定onChange事件,实时更新value值就行了。 123456789101112131415161718192021class Demo extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: props.value &#125; &#125; handleChange(e) &#123; this.setState(&#123; value: e.target.value &#125;) &#125; render() &#123; return ( &lt;input value=&#123;this.state.value&#125; onChange=&#123;e =&gt; this.handleChange(e)&#125;/&gt; ) &#125;&#125; 非受控组件 非受控组件，即组件的状态不受React控制的组件 123456789101112import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Demo extends Component &#123; render() &#123; return ( &lt;input /&gt; ) &#125;&#125;ReactDOM.render(&lt;Demo/&gt;, document.getElementById('content')) 在这个最简单的输入框组件里,我们并没有干涉input中的value展示,即用户输入的内容都会展示在上面。如果我们通过props给组件设置一个初始默认值,defaultValue属性是React内部实现的一个属性,目的类似于input的placeholder属性。 -在构造函数中调用 super(props) 的目的是什么在 super() 被调用之前，子类是不能使用 this 的，在 ES6 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。 123456789101112131415161718192021//使用props：class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); console.log(this.props); // Prints &#123; name: 'sudheer',age: 30 &#125; &#125;&#125;//不使用props：class MyComponent extends React.Component &#123; constructor(props) &#123; super(); console.log(this.props); // Prints undefined // But Props parameter is still available console.log(props); // Prints &#123; name: 'sudheer',age: 30 &#125; &#125; render() &#123; // No difference outside constructor console.log(this.props) // Prints &#123; name: 'sudheer',age: 30 &#125; &#125;&#125; 上面的代码片段揭示了this.props行为仅在构造函数中有所不同,外部构造函数相同。 -何为高阶组件(higher order component) 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。基本上，这是从React的组成性质派生的一种模式，我们称它们为 “纯”组件， 因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件的任何行为。 最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 -除了在构造函数中绑定 this，还有其它方式吗你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。 -应该在 React 组件的何处发起 Ajax 请求在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。 -描述事件在 React 中的处理方式为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。 这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。 -createElement 和 cloneElement 有什么区别 React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。 它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。 12345React.createElement( type, [props], [...children]) React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。 12345React.cloneElement( element, [props], [...children]) -React中有三种构建组件的方式React.createClass()、ES6 class 和无状态函数。 -以下使用React.createElement的等价项是什么123456789101112131415//问题：const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);//以下等同于什么使用 React.createElement ？//答：const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); -使用React Hooks有什么优势 hooks 是react 16.8 引入的特性，他允许你在不写class的情况下操作state和react的其他特性。 hooks 只是多了一种写组件的方法，使编写一个组件更简单更方便，同时可以自定义hook把公共的逻辑提取出来，让逻辑在多个组件之间共享。比如你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 ReactHooks的优点 ：无需复杂的DOM结构，简洁易懂 -为什么类方法需要绑定在JavaScript中， this 的值取决于当前上下文。在React类的组件方法中，开发人员通常希望它引用组件的当前实例，因此有必要 将 这些方法 绑定 到该实例。通常，这是在构造函数中完成的，例如： 123456789101112131415161718192021class SubmitButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isFormSubmitted: false &#125;; this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit() &#123; this.setState(&#123; isFormSubmitted: true &#125;); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleSubmit&#125;&gt;Submit&lt;/button&gt; ) &#125;&#125; -简述 flux 思想 Flux 的最大特点，就是数据的”单向流动”。有四个组成部分 action，dispatcher，view，store 用户访问 ViewView 发出用户的 ActionDispatcher 收到 Action，要求 Store 进行相应的更新Store 更新后，发出一个”change”事件View 收到”change”事件后，更新页面 -简述 redux 思想 redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题。原理是集中式管理，主要有三个核心方法，action，store，reducer view 调用 store 的 dispatch 接收 action 传入 store ，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据， Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰。 一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们。 -redux 有什么缺点一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。 -描述Flux与MVC传统的MVC模式在分离数据（模型），UI（视图）和逻辑（控制器）的关注方面效果很好，但是MVC架构经常遇到两个主要问题： 数据流定义不佳： 跨视图进行的级联更新通常会导致纠结的事件网，难以调试。 缺乏数据完整性： 可以从任何地方对模型数据进行突变，从而在整个UI上产生不可预测的结果。 使用Flux模式，复杂的UI不再受到级联更新的困扰。任何给定的React组件都将能够根据商店提供的数据重建其状态。Flux模式还通过限制对共享数据的直接访问来增强数据完整性。 -React Context是什么 React文档官网并未对 Context 给出“是什么”的定义，更多是描述使用的 Context 的场景，以及如何使用 Context 。 官网对于使用 Context 的场景是这样描述的：In Some Cases, you want to pass data through the component tree without having to pass the props down manuallys at every level. you can do this directly in React with the powerful &quot;context&quot; API. 简单说就是，当你不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现 跨层级 的组件数据传递。 使用props或者state传递数据，数据自顶下流。 使用 Context ，可以跨越组件进行数据传递。 -React Fiber是什么React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法，背后的支持 API 是大名鼎鼎的：requestIdleCallback。 Fiberl是一种将 Reconciliation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。 参考文章： 高质量React面试题 常见react面试题汇总 React组件生命周期概述(16.4)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://www.williamife.com/tags/React/"}]},{"title":"Network 之 Resource Timing字段解析","slug":"浏览器Timing","date":"2020-02-25T06:48:00.000Z","updated":"2020-02-24T09:49:44.597Z","comments":true,"path":"2020/02/25/浏览器Timing/","link":"","permalink":"https://www.williamife.com/2020/02/25/浏览器Timing/","excerpt":"","text":"Resource Timing API提供了让用户查看一个资源从输入url到下载下来经历的各个过程所消耗的时间，借此可以来衡量网站的性能。我们可以通过Resource Timing Api监控哪个阶段消耗时间比较长，然后针对该阶段进行优化。了解网络下载资源的阶段至关重要。这是修复加载问题的基础。 一、浏览器DevTools Queueing队列排队的时间花费。可能由于该请求被渲染引擎认为是优先级比较低的资源（图片）、服务器不可用、超过浏览器并发请求的最大连接数（Chrome的最大并发连接数是6）。 Stalled / Blocking停止/阻塞是浏览器得到要发出这个请求的指令，到请求可以发出的等待时间，一般是代理协商、以及等待可复用的TCP连接释放的时间，不包括DNS查询、建立TCP连接等时间等。 Proxy negotiation代理协商与代理服务器连接的时间花费(如有)。主要是浏览器通过代理服务器去服务目标服务，如本地代理Fiddler，一般无法优化。 DNS LookupDNS查找执行DNS查找的时间，每个新域pagerequires DNS查找一个完整的往返。 DNS查询的时间，当本地DNS缓存没有的时候，这个时间可能是有一段长度的。 Initial connection / Connecting初始连接/连接建立TCP连接的时间，就相当于客户端从发请求开始到TCP握手结束这一段，包括DNS查询+Proxy时间+TCP握手时间。 SSL安全套接层(Secure Sockets Layer 安全套接层)及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 Request sent / Sending请求已发送/正在发送请求第一个字节发出前到最后一个字节发出后的时间（上传时间）。 Waiting（TTFB）等待响应请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte)。通常是耗费时间最长的，通常受到线路、服务器距离等因素的影响。它包含了TCP连接时间，发送HTTP请求时间和获得响应消息第一个字节的时间。 Content Download / Downloading内容下载/下载收到响应的第一个字节，到接受完最后一个字节的时间（下载时间）。浏览器开始收到服务器响应数据的时间=后台处理时间+重定向时间，是反映服务端响应速度的重要指标。 二、Resource Timing Api 所有网络请求都被视为资源。当它们通过网络检索时，分为不同的生命周期。Network(网络)面板使用的Resource Timing API和提供给开发者的API是一样的。 注意: 当使用跨源资源的Resource Timing API时， 请确保所有资源都有CORS头信息。Resource Timing API提供了关于每个单独资源接收时间的详细信息。 请求生命周期的主要阶段是： Redirect立即开始startTime。如果发生重定向, redirectStart也会开始计时。如果重定向发生在此阶段结束时，那么redirectEnd将被采用。 App Cache如果浏览器有缓存，将采用fetchStart时间。 DNSdomainLookupStart 记录DNS请求开始的时间。domainLookupEnd 记录DNS请求结束的时间。 TCPconnectStart 记录开始连接到服务器的时间。如果用了TLS或SSL，secureConnectionStart记录开始连接时间。connectEnd 记录连接完毕时间。 RequestrequestStart记录请求发送到服务器的时间。 ResponseresponseStart记录最开始的响应时间。responseEnd记录响应结束时间。 通过window.performance.getEntriesByType(‘resource’)获取所有的PerformanceResourceTiming： 12345678910111213141516if('performance' in window) &#123; // 获取的是所有的PerformanceResourceTiming var resources = window.performance.getEntriesByType('resource') // 遍历各个资源加载的时间 resources.map((resource) =&gt; &#123; // 这里以图片为例，判断图片加载的时间 if(resource.initiatorType === 'img') &#123; // duration取的是整个过程中经历的时间，即startTime到responseEnd直接的时间, // 即等于resource.responseEnd - resource.startTime if(resource.duration &gt; 5000) &#123; // 图片加载超过了5秒了，上报服务器，提示图片加载过长 reportToServer() &#125; &#125; &#125;)&#125; 注意，上面的代码需要在onload事件上面执行（onload会在图片加载完毕以后调用）。 PerformanceResourceTimeing包含以下的属性： initiatorType：资源的类型，有img、script、link 下面的属性是以毫秒为单位，对应上图 redirectStart redirectEnd fetchStart domainLookupStart domainLookupEnd connectStart connectEnd secureConnectionStart requestStart responseStart responseEnd 所以我们得出这样的一个计算：查看DNS查询时间: domainLookupEnd - domainLookupStart查看TCP三次握手时间: connectEnd - connectStartrequest请求时间: responseEnd - responseStart整个过程时间: responseEnd - startTime 或者 duration 参考文章： Network Resource Timing 我的请求慢在哪 利用Resource Timing监控资源加载速度 Chrome DevTools谷歌浏览器开发者工具了解资源加载时序","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://www.williamife.com/tags/开发/"}]},{"title":"在centos下搭建npm镜像","slug":"NPM","date":"2019-12-01T11:59:00.000Z","updated":"2019-12-19T10:03:18.905Z","comments":true,"path":"2019/12/01/NPM/","link":"","permalink":"https://www.williamife.com/2019/12/01/NPM/","excerpt":"","text":"想搭建一个属于公司内部的 npm 镜像？这边文章或许能帮到你！ 公司开发环境与外网隔绝，需要搭建内网npm源 确保npm服务快速、稳定，提高下载速度 不是搭建 npm 私服，而是镜像源 npmjs.org将自己的项目挂在https://github.com/npm/npm-registry-couchapp。原项目项目地址为：https://github.com/isaacs/npmjs.org。需要制作镜像的同学可以按照说明来制作镜像，首先你需要安装CouchDB 1.4.0或更新的版本。 由于文档较少及项目更新导致操作流程不一致，在实践中出现一些坑，只能亲自填坑。 一、安装CouchDB 使用 YUM 安装，推荐阅读 CouchDB安装以及使用这篇文章，下面列举几个重要的步骤。 12[root@VM_0_9_centos ~]# cat /etc/redhat-releaseCentOS Linux release 7.2.1511 (Core) 1、安装rpm仓库修改/etc/yum.repos.d/bintray-apache-couchdb-rpm.repo，命令如下： vim /etc/yum.repos.d/bintray-apache-couchdb-rpm.repo添加如下内容，保存并退出： 123456[bintray--apache-couchdb-rpm]name=bintray--apache-couchdb-rpmbaseurl=http://apache.bintray.com/couchdb-rpm/el$releasever/$basearch/gpgcheck=0repo_gpgcheck=0enabled=1 2、修改default.ini由于couchdb默认是监听本地的请求，因此你需要配置它，让它可以接受来自局域网内的请求，将配置中的[httpd]段端口和地址前面的分号注释去掉，将127.0.0.1改成0.0.0.0然后重启服务即可。 安装完成之后，启动和停止的命令如下：$ sudo systemctl start couchdb$ sudo systemctl stop couchdb 12port = 5984 // 默认端口号，可修改bind_address = 0.0.0.0 //把127.0.0.1修改为0.0.0.0 启动成功后访问http://localhost:5984/会出现如下图所示： 进入数据库配置页面http://localhost:5984/_utils/# 二、下载couchapp 下面就是couchapp的使用说明了，简单翻译下。 You need CouchDB version 1.4.0 or higher. 1.5.0 or higher is best.你需要CouchDB 1.4.0 以上的版本，yum 会默认安装最新版本，我目前安装的是 2.3.1。 Once you have CouchDB installed, create a new database:curl -X PUT http://localhost:5984/registry使用这个命令创建名为registry数据库，也可以直接在页面上配置。 You’ll need the following entries added in your local.ini然后把这一段内容放进local.ini，我的路径为/opt/couchdb/etc。 123456789[couch_httpd_auth]public_fields = appdotnet, avatar, avatarMedium, avatarLarge, date, email, fields, freenode, fullname, github, homepage, name, roles, twitter, type, _id, _revusers_db_public = true[httpd]secure_rewrites = false[couchdb]delayed_commits = false 最后就是复制整个项目啦，并且执行相应的脚本。用户名和密码不是必须，但最好是创建用户名和密码，否则脚本可能运行出错。 Clone the repository if you haven’t already, and cd into it: 12345678910111213141516git clone git://github.com/npm/npm-registry-couchappcd npm-registry-couchappnpm installnpm start \\ --npm-registry-couchapp:couch=http://admin:password@localhost:5984/registrynpm run load \\ --npm-registry-couchapp:couch=http://admin:password@localhost:5984/registrynpm run copy \\ --npm-registry-couchapp:couch=http://admin:password@localhost:5984/registryvim ~/.npmrc_npm-registry-couchapp:couch=http://admin:password@localhost:5984/registry 会遇到问题的地方上面都过了一遍，在couchdb的web管理界面http://localhost:5984/_utils/#/replication进行同步操作，记得勾选连续Continuous而不是一次性One time，让脚本不停的跑，由于数据量大，同步镜像需要很长时间。 三、测试使用镜像说明文档里提到三种方式，我们直接使用全局配置把registry地址改成我们内网的即可，然后就可以跟平常一样使用npm安装模块，你会发现安装模块时请求的是内网镜像地址了。 npm config set registry http://localhost:5984/registry/_design/app/_rewrite 然后测试一下看看：npm search node Bingo！ 文章中提到的localhost地址记得改成你自己实际的ip地址，在镜像完成同步之前，若你使用npm命令测试安装可能看到404的结果，不要着急。 参考文章： CouchDB安装以及使用 centos下搭建npm镜像","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.williamife.com/tags/Node-js/"},{"name":"Linux","slug":"Linux","permalink":"https://www.williamife.com/tags/Linux/"},{"name":"npm","slug":"npm","permalink":"https://www.williamife.com/tags/npm/"}]},{"title":"Node.js之进程与线程","slug":"Node之线程与进程","date":"2019-11-27T08:15:15.000Z","updated":"2020-03-17T13:32:27.215Z","comments":true,"path":"2019/11/27/Node之线程与进程/","link":"","permalink":"https://www.williamife.com/2019/11/27/Node之线程与进程/","excerpt":"","text":"本篇文章通过Node.js的角度讲解进程与线程，除了介绍概念外还会讲解一些在项目中的实战的应用。 在文章开始前先问几个问题： Node.js是单线程吗？ Node.js 做耗时的计算时候，如何避免阻塞？ Node.js如何实现多进程的开启和关闭？ Node.js可以创建线程吗？ 你们开发过程中如何实现进程守护的？ 除了使用第三方模块，你们自己是否封装过一个多进程架构? 一、 进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。我们启动一个服务、运行一个实例，就是开一个服务进程。多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。 二、 线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。同一块代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage)，线程又有单线程和多线程之分，具有代表性的 JavaScript、Java 语言。 1. 单线程Javascript 就是属于单线程，程序顺序执行，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的使用异步操作。 Google 的V8 Javascript引擎已经在Chrome浏览器里证明了它的性能，所以Node.js的作者Ryan Dahl选择了v8作为Node.js的执行引擎，v8赋予Node.js高效性能的同时也注定了Node.js和大名鼎鼎的Nginx一样，都是以单线程为基础的，当然这也正是作者Ryan Dahl设计Node.js的初衷。 单线程优缺点 高性能首先，单线程避免了频繁创建、切换进程的开销，使执行速度更加迅速。第二，资源占用小，Node.js在大负荷下对内存占用仍然很低。 线程安全单线程的js还保证了绝对的线程安全，不用担心同一变量同时被多个线程进行读写而造成的程序崩溃。线程安全的同时也解放了开发人员，免去了多线程编程中忘记对变量加锁或者解锁造成的悲剧。 异步和非阻塞Node.js是单线程的，但是它如何做到I/O的异步和非阻塞的呢？其实Node.js在底层访问I/O还是多线程的，Node.js的fs模块用到libuv来处理I/O，所以在我们看来Node.js的代码就是非阻塞和异步形式的。 单线程和多核线程是cpu调度的一个基本单位，一个cpu同时只能执行一个线程的任务，同样一个线程任务也只能在一个cpu上执行，所以如果你运行Node.js的机器是像i5，i7这样多核cpu，那么将无法充分利用多核cpu的性能来为Node.js服务。 2. 多线程在C++、C#、python等其他语言都有与之对应的多线程编程，有些时候这很有趣，带给我们灵活的编程方式；但是也可能带给我们一堆麻烦，在编写更多代码的同时也存在着更多的风险，线程的切换和锁也会造成系统资源的开销。 多线程的代价还在于创建新的线程和执行期上下文线程的切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽。 三、 Node.js线程与进程Node.js 是 Javascript 在服务端的运行环境，构建在 chrome 的 V8 引擎之上，基于事件驱动、非阻塞I/O模型，充分利用操作系统提供的异步I/O进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务。 在 Web 服务器方面，著名的 Nginx 也是采用此模式（事件驱动），Nginx 采用 C 语言进行编写，主要用来做高性能的 Web 服务器，不适合做业务。Web业务开发中，如果你有高并发应用场景那么 Node.js 会是你不错的选择。 在单核 CPU 系统之上我们采用 单进程 + 单线程 的模式来开发。在多核 CPU 系统之上，可以通过 child_process.fork开启多个进程（Node.js 在 v0.8 版本之后新增了Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。 注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。 Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。 process.env：环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick：这个在谈及 Event Loop 时经常为会提到 process.pid：获取当前进程id process.ppid：当前进程对应的父进程 process.cwd()：获取当前进程工作目录 process.platform：获取当前进程运行的操作系统平台 process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 进程事件：process.on(&apos;uncaughtException&apos;, cb) 捕获异常信息、 process.on(&apos;exit&apos;, cb）进程推出监听 三个标准流：process.stdout 标准输出、process.stdin 标准输入、 process.stderr 标准错误输 四、 Node.js进程创建 Node.js 提供了 child_process 内置模块，用于创建子进程， 四种方式 child_process.spawn：适用于返回大量数据，例如图像处理，二进制数据处理。 child_process.exec：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。 child_process.execFile：类似 child_process.exec，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为 child_process.fork： 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。 五、 Node.js守护进程守护进程运行在后台不受终端的影响，什么意思呢？比如当我们打开终端执行 node app.js 开启一个服务进程之后，这个终端就会一直被占用，如果关掉终端，服务就会断掉，即前台运行模式。如果采用守护进程进程方式，这个终端我执行 node app.js 开启一个服务进程之后，我还可以在这个终端上做些别的事情，且不会相互影响。 在实际工作中对守护进程的健壮性要求还是很高的，例如：进程的异常监听、工作进程管理调度、进程挂掉之后重启等等，这些还需要我们去不断思考。 六、 总结 单线程的Node.js给我们编码带来了太多的便利和乐趣，我们应该时刻保持清醒的头脑，在Node.js代码中任何一个隐藏的问题都可能击溃整个线上正在运行的Node.js程序。 单线程异步的Node.js不代表不会阻塞，在主线程做过多的任务可能会导致主线程的卡死，影响整个程序的性能，所以我们要非常小心的处理cpu密集型任务，合理的利用各种技术把任务丢给子线程或子进程去完成，保持Node.js主线程的畅通。 线程/进程的使用并不是没有开销的，尽可能减少创建和销毁线程/进程的次数，可以提升我们系统整体的性能和出错的概率。最后请不要一味的追求高性能和高并发，因为我们可能不需要系统具有那么大的吞吐率。高效，敏捷，低成本的开发才是项目所需要的。 参考文章： Node.js进阶之进程与线程 [转][NodeJs系列]Node.js的线程和进程详解","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.williamife.com/tags/Node-js/"}]},{"title":"jQuery架构赏析","slug":"jQuery","date":"2019-09-20T06:14:14.000Z","updated":"2019-11-14T09:07:01.058Z","comments":true,"path":"2019/09/20/jQuery/","link":"","permalink":"https://www.williamife.com/2019/09/20/jQuery/","excerpt":"","text":"在15年之前H5及三大框架流行起来之前，jQuery 是前端不可或缺的技能之一， 据不完全统计至今为止世界上至少还有80%的网站由jQuery构成。jQuery对于现在来说也很有借鉴意义，所以就在网上搜集一些资料整理学习一下。 *本文略有增减* 一、整体架构jQuery 整体框架的结构十分清晰，按代码行文大致分为如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455(function(window, undefined)&#123; //变量、常量、正则初始化 var //对外提供的接口 jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context, rootjQuery ); &#125;; //jQuery对象添加方法和属性 //jQuery的继承方法 //jQuery.extend 扩展一些工具的方法（静态方法） //Sizzle 复杂选择器的实现 //Callbacks 回调对象--函数的统一管理 //Deferred 延迟对象，对异步的统一管理 //support 功能检测 //Data 数据缓存 //queue 队列管理 //Attribute 属性操作 //Event 事件处理 //DOM 操作 //CSS 操作 //ajax //动画 //坐标和大小 //模块化 if ( typeof module === \"object\" &amp;&amp; module &amp;&amp; typeof module.exports === \"object\" ) &#123; module.exports = jQuery; &#125; else &#123; if ( typeof define === \"function\" &amp;&amp; define.amd ) &#123; define( \"jquery\", [], function () &#123; return jQuery; &#125; ); &#125; &#125; if ( typeof window === \"object\" &amp;&amp; typeof window.document === \"object\" ) &#123; window.jQuery = window.$ = jQuery; &#125;&#125;)(window); 二、jQuery闭包结构// 用一个函数域包起来，就是所谓的沙箱// 在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局// 把当前沙箱需要的外部变量通过函数参数引入进来// 只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 第1种写法123(function(window, undefined) &#123; // jQuery 代码&#125;)(window); jQuery 具体的实现，都被包含在了一个立即执行函数构造的闭包里面，为了不污染全局作用域，只在后面暴露 $ 和 jQuery 这 2 个变量给外界，尽量的避开变量冲突。常用的还有另一种写法： 第2种写法123(function(window) &#123; // JS代码&#125;)(window, undefined); 比较推崇的的第一种写法，也就是 jQuery 的写法。二者有何不同呢，当我们的代码运行在更早期的环境当中（pre-ES5，eg. Internet Explorer 8），undefined 仅是一个变量且它的值是可以被覆盖的。意味着你可以做这样的操作：undefined = 42;console.log(undefined) // 42 当使用第一种方式，可以确保你需要的 undefined 确实就是 undefined。这也是 undefined 和 null 的区别之一 另外不得不提出的是，jQuery 在这里有一个针对压缩优化细节，使用第一种方式，在代码压缩的时候，window 和 undefined 都可以压缩为 1 个字母并且确保它们就是 window 和 undefined。 // 压缩策略 1234// w -&gt; windwow , u -&gt; undefined(function(w, u) &#123; ···&#125;)(window); 三、jQuery无new构造嘿，回想一下使用 jQuery 的时候，实例化一个 jQuery 对象的方法： 123456// 无 new 构造$('#test').text('Test');// 当然也可以使用 newvar test = new $('#test');test.text('Test'); 大部分人使用 jQuery 的时候都是使用第一种无 new 的构造方式，直接$(&#39;&#39;)进行构造，这也是 jQuery 十分便捷的一个地方。当我们使用第一种无 new 构造方式的时候，其本质就是相当于 new jQuery()，那么在 jQuery 内部是如何实现的呢？看看： 12345678910111213141516171819202122232425(function(window, undefined) &#123; var // ... jQuery = function(selector, context) &#123; // The jQuery object is actually just the init constructor 'enhanced' // 看这里，实例化方法 jQuery() 实际上是调用了其拓展的原型方法 jQuery.fn.init return new jQuery.fn.init(selector, context, rootjQuery); &#125;, // jQuery.prototype 即是 jQuery 的原型，挂载在上面的方法，即可让所有生成的 jQuery 对象使用 jQuery.fn = jQuery.prototype = &#123; // 实例化化方法，这个方法可以称作 jQuery 对象构造器 init: function(selector, context, rootjQuery) &#123; // ... &#125; &#125; // 这一句很关键，也很绕 // jQuery 没有使用 new 运算符将 jQuery 实例化，而是直接调用其函数 // 要实现这样,那么 jQuery 就要看成一个类，且返回一个正确的实例 // 且实例还要能正确访问 jQuery 类原型上的属性与方法 // jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype // 所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法 jQuery.fn.init.prototype = jQuery.fn;&#125;)(window); 首先要明确，使用 $(‘xxx’) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。 将 jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。 也就是实例化方法存在这么一个关系链jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;new jQuery.fn.init() 相当于 new jQuery() ;jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。 四、jQuery方法的重载jQuery 源码晦涩难读的另一个原因是，使用了大量的方法重载，但是用起来却很方便： 123456789// 获取 title 属性的值$('#id').attr('title');// 设置 title 属性的值$('#id').attr('title','jQuery');// 获取 css 某个属性的值$('#id').css('title');// 设置 css 某个属性的值$('#id').css('width','200px'); 方法的重载即是一个方法实现多种功能，经常又是 get 又是 set，虽然阅读起来十分不易，但是从实用性的角度考虑，这也是为什么 jQuery 如此受欢迎的原因，大多数人使用 jQuery() 构造方法使用的最多的就是直接实例化一个 jQuery 对象，但其实在它的内部实现中，有着 9 种不同的方法重载场景： 123456789101112131415161718192021222324// 接受一个字符串，其中包含了用于匹配元素集合的 CSS 选择器jQuery([selector,[context]])// 传入单个 DOMjQuery(element)// 传入 DOM 数组jQuery(elementArray)// 传入 JS 对象jQuery(object)// 传入 jQuery 对象jQuery(jQuery object)// 传入原始 HTML 的字符串来创建 DOM 元素jQuery(html,[ownerDocument])jQuery(html,[attributes])// 传入空参数jQuery()// 绑定一个在 DOM 文档载入完成后执行的函数jQuery(callback) 五、jQuery.(fn.)extendextend方法在jQuery中是一个很重要的方法，jQuey内部用它来扩展静态方法或实例方法，而且我们开发jQuery插件开发的时候也会用到它。但是在内部，是存在jQuery.fn.extend 和 jQuery.extend两个 extend 方法的，而区分这两个 extend 方法是理解 jQuery 的很关键的一部分。先看结论： 1）jQuery.extend(object) 为扩展jQuery类本身，为类添加新的静态方法；2）jQuery.fn.extend(object) 给jQuery对象添加实例方法，也就是通过这个extend添加的新方法，实例化的jQuery对象都能使用，因为它是挂载在 jQuery.fn上的方法.jQuery.fn = jQuery.prototype 它们的官方解释是：1）jQuery.extend()：把两个或者更多的对象合并到第一个当中，2）jQuery.fn.extend()：把对象挂载到 jQuery 的 prototype 属性，来扩展一个新的 jQuery 实例方法。 使用 jQuery.extend() 拓展的静态方法，我们可以直接使用 $.xxx 进行调用。使用 jQuery.fn.extend() 拓展的实例方法，需要使用 $().xxx 调用。 六、链式调用及回溯这一点的实现相对来说比较简单，只需要在要实现链式调用的方法的返回结果里，返回this，就能够实现链式调用了。 除了链式调用，jQuery 甚至还允许回溯: 12// 通过 end() 方法终止在当前链的最新过滤操作，返回上一个对象集合$('div').eq(0).show().end().eq(1).hide(); 当选择了 (‘div’).eq(0) 之后使用 end() 可以回溯到上一步选中的 jQuery 对象 $(‘div’)，其内部实现其实是依靠添加了 prevObject 这个属性。jQuery 完整的链式调用、增栈、回溯通过 return this 、 return this.pushStack() 、return this.prevObject 实现。 总体来说：1）end() 方法返回 prevObject 属性，这个属性记录了上一步操作的 jQuery 对象合集；2）而 prevObject 属性由 pushStack() 方法生成，该方法将一个 DOM 元素集合加入到 jQuery 内部管理的一个栈中，通过改变 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合；3）当我们在链式调用 end() 方法后，内部就返回当前 jQuery 对象的 prevObject 属性，完成回溯。 七、jQuery正则与细节优化不得不提 jQuery 在细节优化上做的很好，也存在很多值得学习的小技巧。 然后想谈谈正则表达式，jQuery 当中用了大量的正则表达式，我觉得如果研读 jQuery ，正则水平一定能够大大提升，如果是个正则小白，我建议在阅读之前先去了解以下几点： 1）了解并尝试使用 Javascript 正则相关 API，包括了 test() 、replace() 、match() 、exec() 的用法；2）区分上面 4 个方法，哪个是 RegExp 对象方法，哪个是 String 对象方法；3）了解简单的零宽断言，了解什么是匹配不捕获以及匹配且捕获。 八、jQuery 变量冲突处理最后想提一提 jQuery 变量的冲突处理，通过一开始保存全局变量的 window.jQuery 以及 windw.$ 。当需要处理冲突的时候，调用静态方法 noConflict()，让出变量的控制权，源码如下： 1234567891011121314151617181920212223242526272829(function(window, undefined) &#123; var // Map over jQuery in case of overwrite // 设置别名，通过两个私有变量映射了 window 环境下的 jQuery 和 $ 两个对象，以防止变量被强行覆盖 _jQuery = window.jQuery, _$ = window.$; jQuery.extend(&#123; // noConflict() 方法让出变量 $ 的 jQuery 控制权，这样其他脚本就可以使用它了 // 通过全名替代简写的方式来使用 jQuery // deep -- 布尔值，指示是否允许彻底将 jQuery 变量还原(移交 $ 引用的同时是否移交 jQuery 对象本身) noConflict: function(deep) &#123; // 判断全局 $ 变量是否等于 jQuery 变量 // 如果等于，则重新还原全局变量 $ 为 jQuery 运行之前的变量（存储在内部变量 _$ 中） if (window.$ === jQuery) &#123; // 此时 jQuery 别名 $ 失效 window.$ = _$; &#125; // 当开启深度冲突处理并且全局变量 jQuery 等于内部 jQuery，则把全局 jQuery 还原成之前的状况 if (deep &amp;&amp; window.jQuery === jQuery) &#123; // 如果 deep 为 true，此时 jQuery 失效 window.jQuery = _jQuery; &#125; // 这里返回的是 jQuery 库内部的 jQuery 构造函数（new jQuery.fn.init()） // 像使用 $ 一样尽情使用它吧 return jQuery; &#125; &#125;)&#125;(window) 那么让出了这两个符号之后，是否就不能在我们的代码中使用 jQuery 或者呢 $ 呢？莫慌，还是可以使用的： 123456// 让出 jQuery 、$ 的控制权不代表不能使用 jQuery 和 $ ，方法如下：var query = jQuery.noConflict(true);(function($) &#123;// 插件或其他形式的代码，也可以将参数设为 jQuery&#125;)(query);// ... 其他用 $ 作为别名的库的代码 文章转载： 【深入浅出jQuery】源码浅析–整体架构 jQuery v1.10.2源码注解","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.williamife.com/tags/jQuery/"}]},{"title":"从执行上下文，到作用域闭包","slug":"上下文与作用域","date":"2019-08-19T03:07:40.000Z","updated":"2019-08-28T02:48:26.040Z","comments":true,"path":"2019/08/19/上下文与作用域/","link":"","permalink":"https://www.williamife.com/2019/08/19/上下文与作用域/","excerpt":"","text":"上下文与作用域之间有什么样的关系?这一概念看似简单，但很多人都讲不清楚之间的关系。上下文和作用域都是编译原理的知识，具体编程语言有具体的实现规则，本文关注的是 JavaScript 语言的实现。 一、 上下文与作用域上下文(context)是一段程序运行所需要的最小数据集合。我们可以从上下文交换(context switch)来理解上下文，在多进程或多线程环境中，任务切换时首先要中断当前的任务，将计算资源交给下一个任务。因为稍后还要恢复之前的任务，所以中断的时候要保存现场，即当前任务的上下文，也可以叫做环境。 作用域(scope)是标识符（变量）在程序中的可见性范围。作用域规则是按照具体规则维护标识符的可见性，以确定当前执行的代码对这些标识符的访问权限。作用域是在具体的作用域规则之下确定的。 上下文、环境有时候也称作用域，即这两个概念有时候是混用的；不过，上下文指代的是整体环境，作用域关注的是标识符（变量）的可访问性（可见性）。上下文确定了，根据具体编程语言的作用域规则，作用域也就确定了。这就是上下文与作用域的关系。 1234567891011121314151617181920function callWithContext(fn, context) &#123; return fn.call(context);&#125;let name = 'Banana';const apple = &#123; name: \"Apple\"&#125;;const orange = &#123; name: \"Orange\"&#125;;function echo() &#123; console.log(this.name);&#125;echo(); // BananacallWithContext(echo, apple); // ApplecallWithContext(echo, orange); // Orange 12345678910111213141516171819var a = 1;function foo()&#123; // 返回一个箭头函数 return () =&gt; &#123; // this 继承自 foo() console.log( this.a ); &#125;;&#125;var obj1 = &#123; a:2&#125;;var obj2 = &#123; a:3&#125;;foo()() // 1var bar = foo.call( obj1 ); // 调用位置bar.call( obj2 ); // 2foo.call( obj2 )(); // 3 二、 JavaScript的执行 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 当JavaScript代码执行进入一个环境时，就会为该环境创建一个执行上下文，它会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。 JS代码的执行环境 全局环境 函数环境 eval函数环境（不推荐使用） 执行上下文的类型 全局执行上下文 函数执行上下文 eval函数执行上下文 三、 执行上下文 JavaScript运行时首先会进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，那么调用函数，就会进入函数执行环境，对应就会生成该函数的执行上下文。 函数编程中，代码中会声明多个函数，对应的执行上下文也会存在多个。在JavaScript中，通过栈的存取方式来管理执行上下文，我们可称其为执行栈，或函数调用栈(Call Stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中(入栈)；程序执行完成时，它的执行上下文就会被销毁，并从栈顶被推出(出栈)，控制权交由下一个执行上下文。栈结构 因为JS执行中最先进入全局环境，所以处于”栈底的永远是全局环境的执行上下文”。而处于”栈顶的是当前正在执行函数的执行上下文”，当函数调用完成后，它就会从栈顶被推出。 “全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底” 123456789101112131415let color = 'blue';function changeColor() &#123; let anotherColor = 'red'; function swapColors() &#123; let tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 全局上下文只有唯一的一个，它在浏览器关闭时出栈 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此 四、 词法作用域 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 在 JavaScript 中，这个具体的作用域规则就是词法作用域（lexical scope），也就是 JavaScript 中的作用域链的规则。词法作用域是的变量在编译时（词法阶段）就是确定的，所以词法作用域又叫静态作用域（static scope），与之相对的是动态作用域（dynamic scope）。 12345678910111213let a = 2;function foo() &#123; console.log(a); // 会输出2还是3？&#125;function bar() &#123; let a = 3; foo();&#125;bar(); 前面说过，词法作用域也叫静态作用域，变量在词法阶段确定，也就是定义时确定。虽然在 bar 内调用，但由于 foo 是闭包函数，即使它在自己定义的词法作用域以外的地方执行，它也一直保持着自己的作用域。所谓闭包函数，即这个函数封闭了它自己的定义时的环境，形成了一个闭包。（即闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量）所以 foo 并不会从 bar 中寻找变量，这就是静态作用域的特点。 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。 词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 123456789101112function foo() &#123; let a = 0; function bar() &#123; console.log(a); &#125; return bar;&#125;let a = 1;let sub = foo();sub(); // 0; 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。 五、 闭包的应用 模块化、柯里化、模拟块级作用域、命名空间、缓存数据 模块化12345678910111213const tar = (function () &#123; let num = 0; return &#123; addNum: function () &#123; num++; &#125;, showNum: function () &#123; console.log(num); &#125; &#125;&#125;)()tar.addNum();tar.showNum(); 函数柯里化123456let add = function(x)&#123; return function(y)&#123; return x + y &#125;&#125;console.log(add(2)(4)) // 6 模拟块级作用域123456789101112for (var i = 1; i &lt; 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, 0);&#125;function func()&#123; for(var i = 0; i &lt; 5; i++)&#123; + (i =&gt; &#123; setTimeout(() =&gt; console.log(i),300) &#125;)(i) &#125;&#125;func() 命名空间12345678910111213141516171819202122var MyNamespace = &#123;&#125;; MyNamespace.doSomething = function ()&#123; //使用闭包产生的私有类变量 var a, b; //可访问私有变量，但不可被外部访问的私有方法 function setLabel()&#123; // do something... &#125; //可访问私有变量，也可被外部访问的方法 this.getLabel = function()&#123; // do something... &#125;;&#125;// 该方法可被外部访问，却只能通过取/赋值器访问私有类变量 MyNamespace.TreeItem.prototype = &#123; print: function()&#123; console.log( this.getLabel() ); &#125;&#125; Node.js 缓存数据1234567891011121314import &#123;readFileSync&#125; from 'fs';var readContent = (function()&#123; let contentCache = &#123;&#125;; return (bookName)=&gt;&#123; let content = contentCache[bookName]; if (!content)&#123; content = readFileSync(bookName+\".txt\", \"utf8\"); contentCache[bookName] = content; &#125; return content; &#125;;&#125;)(); 参考文章： 执行上下文详细图解 从上下文，到作用域 执行上下文与执行栈，变量对象 词法作用域 VS 动态作用域","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"JS中的防抖与节流","slug":"防抖和节流","date":"2019-07-30T03:08:09.000Z","updated":"2019-08-03T05:32:50.248Z","comments":true,"path":"2019/07/30/防抖和节流/","link":"","permalink":"https://www.williamife.com/2019/07/30/防抖和节流/","excerpt":"","text":"在日常开发中，我们经常会处理各种事件，比如常见的click、scroll、 resize等等。仔细一想，会发现像scroll、scroll、onchange这类事件会频繁触发，如果我们在回调中计算元素位置、做一些跟DOM相关的操作，引起浏览器回流和重绘，频繁触发回调，很可能会造成浏览器掉帧，甚至会使浏览器崩溃，影响用户体验。针对这种现象，目前有两种常用的解决方案：防抖和节流。 一、 防抖（debounce） 所谓防抖，就是指触发事件后，就是把触发非常频繁的事件合并成一次去执行。即在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算。 1. 非立即执行12345678910export default function debounce(fn, wait) &#123; let timeout; return function() &#123; let ctx = this, args = arguments; clearTimeout(timeout); timeout = setTimeout(function() &#123; fn.apply(ctx, args); &#125;, wait); &#125;;&#125; 2. 立即执行123456789101112export default function debounce(fn, wait) &#123; let timeout; return function () &#123; let context = this , args = arguments; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait); if (!timeout) fn.apply(context, args); &#125;&#125; 3. 防抖合并12345678910111213141516171819202122232425/** * @desc 函数防抖 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */export default function debounce(fn, wait, immediate) &#123; let timeout; return function () &#123; let context = this , args = arguments; clearTimeout(timeout); if (immediate) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait); if (!timeout) fn.apply(context, args); &#125; else &#123; timeout = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait); &#125; &#125;&#125; 二、节流（throttle） 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。 1. 时间戳1234567891011function throttle(fn, wait) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this , args = arguments; if (now - previous &gt; wait) &#123; fn.apply(context, args); previous = now; &#125; &#125;&#125; 2. 定时器123456789101112function throttle(fn,wait) &#123; let timeout; return function() &#123; let context = this , args = arguments; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; fn.apply(context, args) &#125;, wait) &#125; &#125;&#125; 3. 节流合并123456789101112131415161718192021222324252627/** * @desc 函数节流 * @param fn 函数 * @param wait 延迟执行毫秒数 * @param type 1 时间戳，0 定时器 */function throttle(fn, wait, type) &#123; let previous = 0 , timeout; return function() &#123; let context = this; let args = arguments; if(type) &#123; let now = Date.now(); if (now - previous &gt; wait) &#123; fn.apply(context, args); previous = now; &#125; &#125;else &#123; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; fn.apply(context, args) &#125;, wait) &#125; &#125; &#125;&#125; 参考文章： JavaScript专题之跟着 underscore 学节流 JavaScript专题之跟着 underscore 学防抖","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"JS中继承的几种方式","slug":"JS中继承的几种方式","date":"2019-06-26T07:25:05.000Z","updated":"2019-07-10T05:43:49.586Z","comments":true,"path":"2019/06/26/JS中继承的几种方式/","link":"","permalink":"https://www.williamife.com/2019/06/26/JS中继承的几种方式/","excerpt":"","text":"我们今天就来了解下 JS 中的继承，在此之前建议学习JS中的原型和原型链的相关知识。 一种面向对象语言需要向开发者提供四种基本能力： 封装 - 把相关的信息（无论数据或方法）存储在对象中的能力聚集 - 把一个对象存储在另一个对象内的能力继承 - 由另一个类（或多个类）得来类的属性和方法的能力多态 - 编写能以多种方法运行的函数或方法的能力 ECMAScript 支持这些要求，因此可被是看做面向对象的。目前来说在 JS 中有 7 中实现方式，让我们一起来学习吧。 一、原型链继承 原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1234567891011121314function ClassA() &#123;&#125;ClassA.prototype.color = \"blue\"ClassA.prototype.sayColor = function () &#123; alert(this.color);&#125;function ClassB() &#123;&#125;ClassB.prototype = new ClassA()ClassB.prototype.constructor = ClassB// 重写prototype会丢失constructor属性 优点：1、实例可继承构造函数的属性，父类构造函数属性，父类原型的属性 缺点：1、新实例无法向父类构造函数传参 2、原型上的属性共享，一个实例修改了原型属性，另一个实例的原型属性也会被修改 二、借用构造函数继承 在子类型的构造函数中调用超类型构造函数。 123456789101112function ClassA(age) &#123; this.age = age&#125;function ClassB(age,name) &#123; this.name = name ClassA.call(this,age)&#125;let ClassC = new ClassB(18,'william')console.log(ClassC) // ClassB &#123; name: 'william', age: 18 &#125; 优点：1、可以向父类构造函数传参 2、解决了原型中包含引用类型值被所有实例共享的问题 缺点：1、只能继承父类构造函数的属性 2、函数无法复用（每次都要调用，每个新实例都有父类构造函数的副本） 三、组合继承 组合继承指的是将原型链继承和借用构造函数继承组合到一块，从而发挥二者之长的一种继承模式，比较常用。 12345678910111213141516171819202122232425function ClassA (age) &#123; this.age = age this.hobby = 'Run'&#125;ClassA.prototype.sayAge = function () &#123; console.log(this.age)&#125;function ClassB (age, name) &#123; this.name = name ClassA.call(this, age)&#125;ClassB.prototype = new ClassA()ClassB.prototype.constructor = ClassBClassB.prototype.sayName = function () &#123; console.log(this.name)&#125;let ClassC = new ClassB(18, 'william')console.log(ClassC) // ClassB &#123; name: 'william', age: 18, hobby: 'Run' &#125;ClassC.sayName() // williamClassC.sayAge() // 18 特点：1、可以继承父类原型上的属性，可以传参，可复用。 2、每个新实例引入的构造函数属性是私有的。 缺点：1、调用了两次父类构造函数，子类的构造函数会代替原型上的那个父类构造函数。 四、原型式继承 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。 12345function ClassObj(obj) &#123; function F ()&#123;&#125; F.prototype = obj return new F()&#125; ECMAScript5通过新增 Object.create()方法规范了原型式继承。在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。 缺点：1、所有实例都会继承原型上的属性。 2、无法实现复用。 五、寄生式继承 在原型式继承的基础上包装一个仅用于封装继承过程的函数，即该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 123456789101112131415161718192021function ClassObj (obj) &#123; function F () &#123; &#125; F.prototype = obj return new F()&#125;function ExtendObj (obj) &#123; let newObj = ClassObj(obj) newObj.sayHi = function () &#123; console.log(this.name) &#125; return newObj&#125;let person = &#123; name: 'William', age: 18&#125;let newPerson = ExtendObj(person)newPerson.sayHi() //William 优点：1、没有创建自定义类型，因为只是套了个壳子返回对象，这个函数顺理成章就成了创建的新对象。缺点：1、使用寄生式继承来为对象添加函数，没用到原型，无法复用。 2、同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 六、寄生组合式继承 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 1234567891011121314151617181920212223// 原型式继承function ClassObj (obj) &#123; function F () &#123; &#125; F.prototype = obj return new F()&#125;function ClassPrototype (subType, superType) &#123; let prorotype = ClassObj(superType.prototype) prorotype.constructor = subType subType.prorotype = prorotype&#125;function ClassA (name, age) &#123; this.name = name this.age = age&#125;function ClassB (name, age, height) &#123; ClassA.call(this, name, age) this.height = height&#125;// ... 优点：只调用了一次超类构造函数,避免在SuberType.prototype上面创建多余的属性，与其同时，原型链还能保持不变。 寄生组合继承是引用类型最理性的继承范式。 七、class…extends S6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法 12345678910111213141516171819202122232425262728293031class Person &#123; //调用类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; //定义一般的方法 sayHi () &#123; console.log(\"调用父类的方法\") console.log(this.name, this.age); &#125;&#125;let person1 = new Person('Tom', 18)person1.sayHi() // Tom 18console.log(person1) // Person &#123; name: 'Tom', age: 18 &#125;//定义一个子类class Human extends Person &#123; constructor(name, age, height) &#123; //通过super调用父类的构造方法 super(name, age) this.height = height &#125; //在子类自身定义方法 sayHi () &#123; console.log(\"调用子类的方法\") console.log(this.name, this.age, this.height); &#125;&#125;let H1 = new Human('Jerry', 18, 180)console.log(H1) //Human &#123; name: 'Jerry', age: 18, height: 180 &#125;H1.sayHi() //Jerry 18 180 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面Parent.apply(this)。 ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 参考文章： JavaScript高级程序设计3 ECMAScript 6 入门 MDN Web Docs","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"使用Nginx部署静态页面","slug":"Nginx","date":"2019-06-14T08:02:02.000Z","updated":"2019-07-10T05:43:49.590Z","comments":true,"path":"2019/06/14/Nginx/","link":"","permalink":"https://www.williamife.com/2019/06/14/Nginx/","excerpt":"","text":"最近和朋友在一起开发个人项目，需要部署至服务器对外展示，但是环境神码的都是从 0 开始，下面就简单说下如何用 Nginx 部署一个的静态网站。 一、 准备环境 云服务器 腾讯云 你的代码 GitHub 一台电脑 蔡徐坤 本文案例使用基于以太坊区块链上的永存的留言DAPP项目 二、 环境配置使用 shell 登录服务器，由于服务器系统是 CentOS 系统，故选择yum安装Nginx较为方便（可使用其它方式安装）yum install -y nginx 安装完成后使用命令：(1) 开始启动：nginx(2) 测试Nginx配置是否正确：nginx -t(3) 优雅重启：nginx -s reload 三、 开始部署进入 Nginx 配置路径：cd /etc/nginx/-&gt;vim nginx.conf或者 cd /etc/nginx/conf.d 新增一个配置文件 12345678910111213141516171819202122server &#123; ······ listen 80 default_server; # listen [::]:80 default_server; server_name vowsonblockchain.xyz; # Load configuration files for the default server block. location / &#123; root /root/william/vowsonblockchain/build_webpack; index index.html; try_files $uri $uri/ /index.html; &#125; # location ~* ^.+\\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123; # root /root/william/vowsonblockchain/build_webpack; #&#125; ······&#125; SPA项目记得加上try_files $uri $uri/ /index.html;保存完文件之后再执行nginx -s reload就可以开始愉快的访问你的网站了。 四、 遇到问题在实践过程中并没有什么特别难以理解的地方，重点是知道遇到何种问题才好解决。一些常见的问题可阅读以下文章对号入座，放上链接，文章就不搬了。 使用yum安装 Nginx Nginx 服务的基本配置 Nginx 出现 403 Forbidden 最终解决 Nginx 服务器证书安装 Nginx 从入门到实践","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.williamife.com/tags/Nginx/"}]},{"title":"在项目中使用Mock.js的基本步骤","slug":"Mock","date":"2019-05-29T09:48:22.000Z","updated":"2019-07-10T05:43:49.589Z","comments":true,"path":"2019/05/29/Mock/","link":"","permalink":"https://www.williamife.com/2019/05/29/Mock/","excerpt":"","text":"在日常工作中，往往会出现后端接口还没有开发完成。这时我们可以根据已有的接口文档来搭建web server自己模拟假数据,拦截 Ajax 请求,返回模拟的响应数据。 一、开始 &amp; 安装1234//我们使用axios来发起http请求npm install axios --save//安装依赖mockjsnpm install mockjs --save-dev 二、拦截 &amp; 响应拦截并响应浏览器的http请求 1.在src目录下新建mock目录，结构如下： 2.index.js内容如下： 123const Mock = require('mockjs');//格式： Mock.mock( url, post/get , 返回的数据)；Mock.mock('/user/userInfo', 'get', require('./json/userInfo')); 3.json文件内容如下，以userInfo.json为例： 1234567891011&#123; \"data\": &#123; \"userid\": \"@id()\", \"username\": \"@cname()\", \"date\": \"@date()\", \"avatar\": \"@image('200x100', '#02adea', 'Hello')\", \"description\": \"@paragraph()\", \"ip\": \"@ip()\", \"email\": \"@email()\" &#125;&#125; 4.在main.js入口文件中引入mock数据，不需要时，则注释掉。 1234567891011121314import Vue from 'vue';import App from './App';import router from './router';require('./mock'); //引入mock数据，关闭则注释该行Vue.config.productionTip = false;new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 3、在vue模板访问 123456axios.get('/user/userInfo').then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;); 项目地址","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"JS中的数据结构和算法","slug":"JS数据结构与算法","date":"2019-05-10T04:20:10.000Z","updated":"2020-09-09T07:40:28.831Z","comments":true,"path":"2019/05/10/JS数据结构与算法/","link":"","permalink":"https://www.williamife.com/2019/05/10/JS数据结构与算法/","excerpt":"","text":"一、 前言在以往的工作经验中，数据结构和算法对于很多前端工程师来说，一直是可有可无的。但个人觉得，前端工程师其实也是需要重视数据结构和算法的，因为前端所做的东西是用户访问网站第一眼看到的东西，特别在移动浪潮到来之后，对用户体验越来越高，对前端提出了更高的要求，面对越来越复杂的产品，需要坚实的数据结构和算法基础才能驾驭。 如果没有学习过计算机科学的程序员，当我们在处理一些问题时，比较熟悉的数据结构就是数组，数组无疑是一个很好的选择。但很多时候，对于很多复杂的问题，数组就显得太过简陋了，当学习了数据结构和算法之后，对于很多编程问题，当想到一个合适的数据结构后，设计和实现解决这些问题的算法就手到擒来。 数据结构：列表、栈、队列、链表、字典、散列、图和二叉查找树 排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序和快速排序 查找算法：顺序查找和二分查找 二、 数据结构1. 列表在日常生活中，人们经常使用列表：待办事项列表、购物清单、最佳十名榜单等等。而计算机程序也在使用列表，它是一组有序的数据，每个列表中的数据项称为元素。在JS中，列表中的元素可以是任意数据类型。列表中可以保存多少元素并没有限定（在实际使用时会受到程序内存的限制）。 列表的数据结构较为简单，不需要在一个长序列中查找元素，或者对其进行排序。反之，如果数据结构非常复杂，列表的作用就没有那么大了。 2. 栈栈Stack是一种 LIFO (Last-In-First-Out) 后进先出的数据结构，是一种特殊的列表。想象一下，我们平常在饭馆见到的一摞盘子就是现实世界常见的栈的例子，只能从最上面取盘子，盘子洗干净后，也只能放在最上面。 栈是一种高效的数据结构，因为栈内的元素只能通过列表的一端访问，这一端称为栈顶。只要数据的保存满足后入先出或先进后出的原理，都优先考虑使用栈。 3. 队列队列Queue是典型的 FIFO (First-In-First-Out) 先进先出的数据结构，也是一种特殊的列表，不同的是队列只能在队尾插入元素，在队首删除元素。想象一下，我们在银行排队，排在最前面的人第一个办理业务，而后面来的人只能排在队伍的后面，直到轮到他们为止。 消息机制可以通过队列来实现，进程调度也是使用队列来实现。 只要数据的保存满足先进先出、后入后出的原理，都优先考虑使用队列。 4. 链表链表LinkedList也是一种列表，与其他语言（比如C++和Java）的数组相比，在JavaScript中数组被实现成了对象，数组的索引下标需要在js语言内部转换为js对象的属性名，因此效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。 单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。 双链表以类似的方式工作，但还有一个引用字段，称为“prev”字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。 循环链表 和单链表相似，节点类型都是一样，唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性执行它本身。 在实际应用中，除了有随机访问的需求之外，其他情况都可以用链表替换数组。 5. 字典字典Dictionary是一种以键-值对存储数据的数据结构，JavaScript中的Object类就是以字典的形式设计的。JavaScript可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能。 对象在JavaScript编写中随处可见，所以字典的作用也异常明显了。 6. 散列散列Hash（也称为哈希表）是一种的常用的数组存储技术，散列后的数组可以快速地插入或取用。散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但对于查找操作来说却效率低下，比如查找一组数组中的最大值和最小值。这些操作需要求助于其他数据结构，比如二叉查找树。 散列表在JavaScript中可以基础数组去进行设计。数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。 哈希表的关键思想是使用哈希函数将键映射到存储桶 即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法。 哈希表可以用于数据的插入、删除和取用，不适用于查找数据。 7. 图图Graph由边的集合及顶点的集合组成。 顶点代表对象，边则建立起对象之间的关系或关联。如果一个图的顶点对是有序的，则称之为有向图（如流程图），反之，称之为无序图。 图的存储结构一般为邻接矩阵和邻接表。 搜索图的算法主要有两种：深度优先搜索和广度优先搜索。 8. 二叉树树Tree一种非线性的数据结构，以分层的方式存储数据。在树结构中，每一个结点只有一个前件，称为父结点，没有前件的结点只有一个，称为树的根结点，简称树的根（root）。每一个结点可以有多个后件，称为该结点的子结点。没有后件的结点称为叶子结点。一个结点所拥有的子结点的个数称为该结点的度，所有结点中最大的度称为树的度。树的最大层次称为树的深度。 二叉树每个节点的子节点不允许超过两个。一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为2，可以写出高效的程序在树中插入、查找和删除数据。 按照根节点访问的顺序不同，树的遍历分为以下三种： 前序遍历：根节点-&gt;左子树-&gt;右子树 ABDEFGC 中序遍历：左子树-&gt;根节点-&gt;右子树 DEBGFAC 后序遍历：左子树-&gt;右子树-&gt;根节点 EDGFBCA 二叉查找树BST（Binary Sort Tree）是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。 由于树存储的所有元素之间具有明显的层次特性，因此常被用来存储具有层级关系的数据，比如文件系统中的文件；也会被用来存储有序列表等。 三、 排序算法普通排序算法 普通排序算法基本核心思想是指对一组数组按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的for循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。 1. 冒泡排序冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 12345678910111213141516171819202122232425262728293031323334// 基础版function bubbleSort (arr) &#123; let i = 0, j = 0 for (i; i &lt; arr.length - 1; i++) &#123; for (j; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp; &#125; &#125; &#125; return arr&#125;// 优化版function bubbleSort (arr) &#123; let i = arr.length while (i &gt; 0) &#123; let pos = 0, j = 0 for (j; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j+1])&#123; pos = j let temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; i = pos &#125; return arr&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];bubbleSort(arr)// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 2. 选择排序选择排序 (Selection Sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112131415161718192021function selectionSort (arr) &#123; let len = arr.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; temp = arr[minIndex] arr[minIndex] = arr[i] arr[i] = temp &#125; return arr&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 3. 插入排序插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 12345678910111213141516function insertSort (arr) &#123; let len = arr.length for (i = 1; i &lt; len; i++) &#123; let key = arr[i] let j = i - 1 while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123; arr[j + 1] = arr[j] j--; &#125; arr[j + 1] = key &#125; return arr&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(insertSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 高级排序算法 高级数据排序算法，通常用于处理大型数据集的最高效排序算法，它们处理的数据集可以达到上百万个元素，而不仅仅是几百个或者几千个，下面我们将介绍希尔排序、归并排序和快速排序。 4. 希尔排序1959年Shell(Shell Sort)发明，第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。 123456789101112131415161718192021function shellSort (arr) &#123; let len = arr.length; let temp, gap = 1; while (gap &lt; len / 3) &#123; gap = gap * 3 + 1 &#125; while (gap &gt;= 1) &#123; for (let i = gap; i &lt; len; i++) &#123; temp = arr[i] for (let j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j] &#125; arr[j + gap] = temp &#125; gap = (gap - 1) / 3 &#125; return arr&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 5. 归并排序归并排序(Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 1234567891011121314151617181920212223242526272829function mergeSort (arr) &#123; let len = arr.length if (len &lt; 2) &#123; return arr &#125; let middle = Math.floor(len / 2) let left = arr.slice(0, middle) let right = arr.slice(middle) return merge(mergeSort(left), mergeSort(right));&#125;function merge (left, right) &#123; let result = [] while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt; right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; while (left.length) &#123; result.push(left.shift()) &#125; while (right.length) &#123; result.push(right.shift()) &#125; return result&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(mergeSort(arr)); 6. 快速排序快速排序(Quick Sort)是处理大数据集最快的排序算法之一。 它是一种分而治之的算法，通过递归的方法将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤知道所有数据都是有序的。这个算法首先要在列表中选择一个元素作为基准值。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。 123456789101112131415161718function qSort (arr) &#123; if (arr.length == 0) &#123; return [] &#125; let left = [] let right = [] let pivot = arr[0] for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return qSort(left).concat(pivot, qSort(right))&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(qSort(arr)); 四、 查找算法在列表中查找数据有两种方式：顺序查找和二分查找。顺序查找适用于元素随机排列的列表；二分查找适用于元素已排序的列表。二分查找效率更高，但是必须在进行查找之前花费额外的时间将列表中的元素排序。 1. 顺序查找 对于查找数据，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判断，直到找到了想要的结果，或者直到列表结尾也没有找到。这种方法称为顺序查找，有时也被称为线性查找。 12345678910function seqSearch (arr, data) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === data) &#123; return i; &#125; &#125; return -1;&#125;let arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(seqSearch(arr, 15)) 2. 二分查找 二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。 查找过程可以分为以下步骤：首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。如果某一步数组为空，则表示找不到目标元素。 1234567891011121314151617function binSearch (arr, data) &#123; let low = 0; let high = arr.length - 1 while (low &lt;= high) &#123; let middle = Math.floor((low + high) / 2) if (arr[middle] &lt; data) &#123; low = middle + 1 &#125; else if (arr[middle] &gt; data) &#123; high = middle - 1 &#125; else &#123; return middle &#125; &#125; return -1&#125;let arr = [1,2,3,4,5,6,7,8,9,10,11];console.log(binSearch(arr, 10)) 参考文章： 十大经典算法总结(Javascript描述) JS中的算法与数据结构","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.williamife.com/tags/Node-js/"}]},{"title":"JS中的原型和原型链","slug":"JS中的原型和原型链","date":"2019-04-29T11:01:55.000Z","updated":"2019-07-10T05:43:49.586Z","comments":true,"path":"2019/04/29/JS中的原型和原型链/","link":"","permalink":"https://www.williamife.com/2019/04/29/JS中的原型和原型链/","excerpt":"","text":"在基于类的传统面向对象的编程语言中，对象由类实例化而来，实例化的过程中，类的属性和方法会拷贝到这个对象中；对象的继承实际上是类的继承，在定义子类继承于父类时，子类会将父类的属性和方法拷贝到自身当中。因此，这类语言中，对象创建和继承行为都是通过拷贝完成的。但在JavaScript中，对象的创建、对象的继承（更好的叫法是对象的代理，因为它并不是传统意义上的继承）是不存在拷贝行为的。(ES6 中的class也只不过是语法糖，并非真正意义上的类) 一、 原型在JavaScript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype，正如下面所展示的。原型是为了共享多个对象之间的一些共有特性（属性或方法），这个功能也是任何一门面向对象的编程语言必须具备的。 123456789101112131415161718function doSomething()&#123;&#125;console.log( doSomething.prototype );// doSomething 函数有一个默认的原型属性，它在控制台上面呈现了出来.// 运行这段代码之后，控制台上面应该出现了像这样的一个对象.&#123; constructor: ƒ doSomething(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 二、 原型链JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 JavaScript中的对象，都有一个内置属性[[Prototype]]，指向这个对象的原型对象。当查找一个属性或方法时，如果在当前对象中找不到定义，会继续在当前对象的原型对象中查找；如果原型对象中依然没有找到，会继续在原型对象的原型中查找(原型也是对象，也有它自己的原型)；如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。可以看出，这个查找过程是一个链式的查找，每个对象都有一个到它自身原型对象的链接，这些链接组建的整个链条就是原型链。拥有相同原型的多个对象，他们的共同特征正是通过这种查找模式体现出来的。 在doSomething的例子中，我们可以看到最顶层的原型对象，这个对象就是Object.prototype，这个对象中保存了最常用的方法，如toString、valueOf、hasOwnProperty等，因此我们才能在任何对象中使用这些方法。 三、 prototypeprototype 属性：继承成员被定义的地方 在 JavaScript 原型继承结构里面，规范中用 [[Prototype]] 表示对象隐式的原型，在 JavaScript 中用 __proto__ 表示，在 Firefox 和 Chrome 浏览器中是可以访问得到这个属性的，在 IE 下不行。所有 JavaScript 对象都有 __proto__ 属性，但只有 Object.prototype.__proto__为 null ，前提是没有修改过这个属性。这个属性指向它的原型对象。 至于显示的原型，在 JavaScript 里用 prototype 属性表示。 四、 constructor每个实例对象都从原型中继承了一个 constructor 属性，该属性指向了用于构造此实例对象的构造函数。 一个小技巧是，你可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 new 关键字，便能将此函数作为构造器使用。 12345678910111213141516171819function deepClone(obj) &#123; //递归拷贝 if(obj === null) return null; //null 的情况 if(obj instanceof RegExp) return new RegExp(obj); if(obj instanceof Date) return new Date(obj); if(typeof obj !== 'object') &#123; //如果不是复杂数据类型，直接返回 return obj; &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor(); for(let key in obj) &#123; //如果 obj[key] 是复杂数据类型，递归 t[key] = deepClone(obj[key]); &#125; return t;&#125; 五、 注意事项对象的原型（可以通过Object.getPrototypeOf()或者已被弃用的__proto__属性获得）与构造函数的 prototype 属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。 1234Object.getPrototypeOf(new String()) === String.prototype // trueObject.getPrototypeOf(new Number()) === Number.prototype // trueObject.getPrototypeOf(new Object()) === Object.prototype // trueObject.getPrototypeOf(new Array()) === Array.prototype // true Q: 如何创造一个既没有属性方法也没有原型链的空对象? 1234let nullObject = Object.create(null);// &#123;&#125; No propertiesnullObject.__proto__; // undefinednullObject.prototype; // undefined 参考文章： 白话原型和原型链 JavaScript instanceof 运算符深入剖析 MDN Web Docs","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"I/O模型、Libuv和Eventloop","slug":"浅谈IO模型与Event Loop","date":"2019-03-28T08:40:00.000Z","updated":"2019-07-10T05:43:49.593Z","comments":true,"path":"2019/03/28/浅谈IO模型与Event Loop/","link":"","permalink":"https://www.williamife.com/2019/03/28/浅谈IO模型与Event Loop/","excerpt":"","text":"一、I/O模型①常见的IO模型：Linux(UNIX)操作系统中的网络IO模型为例 Blocking I/O 同步阻塞IO Non-blocking I/O 同步非阻塞IO I/O Multiplexing IO多路复用 Signal-blocking I/O 信号驱动IO Asynchronous I/O 异步IO ②基本概念的定义： IO 指的是输入输出，通常指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。简而言之，从硬盘中读写数据或者从网络上收发数据，都属于IO行为。 IO：内存IO、网络IO和磁盘IO，通常我们说的IO指的是后两者。 阻塞和非阻塞：在调用结果在返回之前，当前线程是否挂起，即发起IO请求是否会被阻塞。 同步和异步：如果做阻塞I/O调用，应用程序等待调用的完成的过程就是一种同步状况。相反，I/O为非阻塞模式时，应用程序则是异步的。 ③完成一次IO的过程：以读一个文件为例,一个IO读过程是文件数据从磁盘→内核缓冲区→用户内存的过程。 同步与异步的区别主要在于数据从内核缓冲区→用户内存这个过程需不需要用户（应用）进程等待，即实际的IO读写是否阻塞请求进程。(网络IO可把磁盘换做网卡) 1、同步阻塞IO 阻塞 I/O是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。 应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。 2、同步非阻塞IO 应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回 error ，应用进程在得到 error 后，过一段时间再发送 recvfrom 请求。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。在发送请求的时间间隔中，进程可以先做别的事情。 3、IO多路复用 IO多路复用是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。 这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。 4、信号驱动IO 应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。 5、异步IO 应用进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。 6、五种IO模型对比 阻塞IO模型、非阻塞IO模型、IO多路复用和信号驱动IO模型都是同步的IO模型，因为无论以上那种模型，真正的数据拷贝过程，都是同步进行的。 二、Libuvlibuv是一个高性能事件驱动库，屏蔽了各种操作系统的差异从而提供了统一的API。libuv严格使用异步、事件驱动的编程风格。其核心工作是提供事件循环及 基于I/O 或其他活动事件的回调机制。libuv库包含了诸如计时器、非阻塞网络支持、异步文件系统访问、线程创建、子进程等核心工具。 1、 句柄和请求libuv给用户提供了两种方式与event loop一起协同工作，一个是句柄(handle)一个是请求(request)。 句柄(handle)代表了一个长期存在的对象，这些对象当处于活跃状态的时候能够执行特定的操作。例如：一个准备（prepare）句柄在活跃的时候可以在每个循环中调用它的回调一次。一个TCP服务器的句柄在每次有新的连接的时候都会调用它的连接回调函数。 请求(request)一般代表短时操作。这些操作能用作用于句柄之上。写请求用于在句柄上写数据；还有一些例外，比如说getaddrinfo请求不需要句柄而是直接在循环中执行。 2、 I/O循环I/O循环或者叫做事件循环是整个libuv的核心部分。I/O循环建立了所有IO操作的执行环境，I/O循环会被绑定在一个线程之上。我们可以运行多个事件循环，只要每一个都运行在不同的线程之上。libuv事件循环不是线程安全的，所以所有包含事件循环的API及句柄都不是线程安全的。 事件循环遵循最普遍的单线程异步I/O方法：所有I/O或者网络操作在非阻塞的socket上执行，这个socket会使用基于平台的组好的poll机制：在linux上使用epoll，在OSX和其他BSD平台上使用kqueue，在sunOS上使用event ports，在windows上使用IOCP。作为循环迭代的一部分，循环会阻塞以等待socket上的I/O活动，这些活动已经被加到socket的触发实践中了，一旦这些条件满足，那么socket的状态就会发生变化，从而循环不再阻塞，而且句柄也可以读、写及执行其他期望的I/O操作。 更好的理解事件循环操作如何进行，下图展示了一个循环迭代的所有阶段。 文件 I/O 与网络 I/O 不同 ，并不存在 libuv 可以依靠的各特定平台下的文件 I/O 基础函数，所以目前的实现是在线程中执行阻塞的文件 I/O 操作来模拟异步。 注意：libuv利用线程池技术使得异步文件I/O操作称为可能，但是对于网络IO只能执行在一个单一线程中，即loop的线程中。 三、Event Loop 任务队列 异步任务分为task（宏任务，也可称为macroTask）和microtask（微任务）两类。当满足执行条件时，task和microtask会被放入各自的队列中等待放入主线程执行，我们把这两个队列称为Task Queue(Macrotask Queue)和Microtask Queue。 MacroTask（宏任务） script代码、setTimeout、setInterval、setImmediate(浏览器IE10)、MessageChannel、I/O、UI-Rendering MicroTask（微任务） Process.nextTick(Node独有)、Promise、MutationObserver、Object.observe(废弃) 1、 浏览器 E-LJS调用栈采用的是先进后出原则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 执行栈在执行完同步任务后 ，查看执行栈是否为空，如果执行栈为空，就会去检查微任务microTask队列是否为空，如果为空的话，就执行Task（宏任务），否则执行微任务。 每当单个宏任务执行完毕后 ，检查microTask队列是否为空，如果不为空，会按照 先入先出 原则全部执行microTask队列，设置microTask队列为null，然后再执行宏任务，如此反复。 1234567891011121314console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// script start、script end、promise1、promise2、setTimeout Another One 12345678910111213141516171819202122232425console.log('script start')async function async1() &#123; await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2 end')&#125;async1()setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)new Promise(resolve =&gt; &#123; console.log('Promise') resolve()&#125;).then(function() &#123; console.log('promise1')&#125;).then(function() &#123; console.log('promise2')&#125;)console.log('script end') async/await 在底层转换成了 promise 和 then 回调函数。 每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中代码的操作放到 then 回调函数中。 关于Chrome73以下版本和73版本的区别 在老版本版本以下，先执行promise1和promise2，再执行async1。script start、async2 end、Promise、script end、promise1、promise2、async1 end、setTimeout 在73版中，先执行async1再执行promise1和promise2。script start、async2 end、Promise、script end、async1 end、promise1、promise2、setTimeout 主要原因是因为在谷歌73版本中更改了规范 2、 Node E-L 在Node中事件每一轮循环按照顺序分为6个阶段，来自libuv的实现： ┌───────────────────────┐ ┌─&gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │&lt;─────┤ connections, │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ 123456timers：执行满足条件的setTimeout、setInterval回调。I/O callbacks：是否有已完成的I/O操作的回调函数，来自上一轮的poll残留。idle，prepare：可忽略poll：等待还没完成的I/O事件，会因timers和超时时间等结束等待。check：执行setImmediate的回调。close callbacks：关闭所有的closing handles，一些onclose事件。 我们需要重点关心的是timers、poll、check这三个阶段。 1. timers执行setTimeout和setInterval中到期的callback，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于system的调度可能会延时，达不到预期时间。 2. poll执行I/O回调 和 处理轮询队列中的事件。 ① 如果 poll 队列不是空的，event loop 就会依次执行队列里的回调函数，直到队列被清空或者到达 poll 阶段的时间上限。 ② 如果 poll 队列是空的，就会： 有 setImmediate 任务，event loop 就结束 poll 阶段去往 check 阶段。 没有 setImmediate 任务，event loop 就会等待新的回调函数进入 poll 队列，并立即执行它。 3. check此阶段允许人员在poll阶段完成后立即执行回调。 setImmediate()实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它是通过 libuv 里一个能将回调安排在 poll 阶段之后执行的 API 实现的。 在poll队列是空的 且有 setImmediate 任务的情况下，event loop 就结束 poll 阶段去往 check 阶段执行任务。 1234567891011121314151617console.log('start')setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)Promise.resolve().then(function() &#123; console.log('promise3')&#125;)console.log('end') 如果node版本为v11.x， 其结果与浏览器一致： start end promise3 timer1 promise1 timer2 promise2 v10如果time2定时器已经在执行队列中结果为： start end promise3 timer1 timer2 promise1 promise2 否则和第一个结果一致。 了解浏览器的eventloop可能就知道，浏览器的宏任务队列执行了一个，就会执行微任务。 简单的说，可以把浏览器的宏任务和node10的timers比较，就是node10只有全部执行了timers阶段队列的全部任务才执行微任务队列，而浏览器只要执行了一个宏任务就会执行微任务队列。 node11保持和浏览器相同。 1. setImmediate &amp;&amp; setTimeoutsetImmediate和setTimeout是相似的，但根据它们被调用的时间以不同的方式表现。 setImmediate()设计用于在当前poll阶段完成后check阶段执行脚本 。setTimeout()为最小（ms）后运行的脚本，在timers阶段执行。 12345678910setTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;);// timeout,immediate// immediate,timeout 1234567891011const fs = require('fs');fs.readFile('../file.txt', () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;);// immediate,timeout 2. Process.nextTickprocess.nextTick()虽然它是异步API的一部分，但从技术上讲，它不是事件循环的一部分。 process.nextTick()方法将 callback 添加到next tick队列。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。 当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 1234Promise.resolve().then(() =&gt; console.log('Promise'));process.nextTick(() =&gt; console.log('nextTick'));// nextTick// Promise 12345678910111213141516171819202122232425262728setImmediate(() =&gt; &#123; console.log('setImmediate1'); setTimeout(() =&gt; &#123; console.log('setTimeout1'); &#125;, 0);&#125;);setTimeout(() =&gt; &#123; process.nextTick(() =&gt; console.log('nextTick')); console.log('setTimeout2'); setImmediate(() =&gt; &#123; console.log('setImmediate2'); &#125;);&#125;, 0);//结果1// setImmediate1// setTimeout2// setTimeout1// nextTick// setImmediate2// 结果2// setTimeout2// nextTick// setImmediate1// setImmediate2// setTimeout1 JavaScript是单线程的，但Node本身其实是多线程的，除了用户代码无法并行执行外，所有的I/O请求是可以并行执行的。事件循环是Node异步I/O实现的核心，Node通过事件驱动的方式处理请求，使得其无须为每个请求创建额外的线程，省掉了创建和销毁线程的开销。同时也因为线程数较少，不受线程上下文切换的影响，维持了Node的高性能。Node异步IO、非阻塞的特性，使它非常适用于IO密集、高并发的应用场景。 参考文章： Linux下五种I/O模型详解 高并发I/O模型 [译]libuv 设计概述 Eventloop不可怕，可怕的是遇上Promise 又被node的eventloop坑了，这次是node的锅","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://www.williamife.com/tags/Node-js/"},{"name":"Libuv","slug":"Libuv","permalink":"https://www.williamife.com/tags/Libuv/"},{"name":"I/O模型","slug":"I-O模型","permalink":"https://www.williamife.com/tags/I-O模型/"}]},{"title":"关于6种Web安全常见的攻防姿势","slug":"关于Web安全常见的攻防姿势","date":"2019-03-21T09:10:00.000Z","updated":"2019-11-27T08:04:18.345Z","comments":true,"path":"2019/03/21/关于Web安全常见的攻防姿势/","link":"","permalink":"https://www.williamife.com/2019/03/21/关于Web安全常见的攻防姿势/","excerpt":"","text":"关于Web安全的问题，是一个老生常谈的问题，作为离用户最近的一层，我们大前端应该把手伸的更远一点。 我们最常见的Web安全攻击有以下几种： XSS 跨站脚本攻击 CSRF 跨站请求伪造 URL 跳转漏洞 ClickJacking 点击劫持/UI-覆盖攻击 SQL Injection SQL注入 OS Command Injection OS命令注入 一、XSS XSS （Cross Site Script），中文是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 XSS攻击可以分为3类： 反射型 - 非持久型 Reflected XSS 存储型 - 持久型 Stored XSS 基于DOM或本地的XSS DOM-based or local XSS 1. 反射型反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。 \b假装我是一个恶意链接（Click Me~） node1234567891011const http = require('http');// 启http服务const server = http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', '*'); res.writeHead(200, &#123;'Content-Type': 'text/html; charset=UTF-8'&#125;); res.write('&lt;script&gt;while(true)alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;);server.listen('8000'); 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。 2. 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 html12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;存储型 XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Try Me：&lt;input type=\"text\" id=\"input\"&gt;&lt;/div&gt; &lt;button id=\"btn\"&gt;Submit&lt;/button&gt; &lt;script&gt; const input = document.getElementById('input'); const btn = document.getElementById('btn'); let val; input.addEventListener('change', e =&gt; &#123; val = e.target.value; &#125;, false); btn.addEventListener('click', e =&gt; &#123; fetch('http://localhost:8000/save', &#123; method: 'POST', body: val &#125;); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; node1234567891011121314151617181920212223242526272829303132const http = require('http');let userInput = '';function handleReequest (req, res) &#123; const method = req.method; res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Headers', 'Content-Type') if (method === 'POST' &amp;&amp; req.url === '/save') &#123; let body = ''; req.on('data', chunk =&gt; &#123; body += chunk; &#125;); req.on('end', () =&gt; &#123; if (body) &#123; userInput = body; &#125; res.end(); &#125;); &#125; else &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=UTF-8' &#125;); res.write(userInput); res.end(); &#125;&#125;// 启http服务const server = http.createServer((req, res)=&gt; &#123; handleReequest(req, res)&#125;);server.listen('8000'); 3. 基于DOM基于DOM或本地的XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 html12345678910111213141516171819&lt;body&gt;&lt;input type=\"text\" id=\"input\"&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById('input'); const btn = document.getElementById('btn'); const div = document.getElementById('div'); let val; input.addEventListener('change', (e) =&gt; &#123; val = e.target.value; &#125;, false); btn.addEventListener('click', () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;Try Me~&lt;/a&gt;` &#125;, false);&lt;/script&gt;&lt;/body&gt; 总结:XSS攻击的本质就是，利用一切手段在目标用户的浏览器中执行攻击脚本。 防范:对于一切用户的输入、输出、客户端的输出内容视为不可信，在数据添加到DOM或者执行了DOM API的时候，我们需要对内容进行HtmlEncode或JavaScriptEncode，以预防XSS攻击。 现在主流的浏览器内置了防范 XSS 的措施，例如 内容安全策略(CSP)。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。 二、CSRF CSRF(Cross-site request forgery)跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。 关于浏览器的Cookie\b策略请参考HTTP Cookie。 1. 通过 Cookie 进行 CSRF 攻击假设有一个BBS站点http://www.a.com: 当用户登录之后，会设置如下 cookie：res.setHeader(&#39;Set-Cookie&#39;, [&#39;user=william; expires=Fri, 23 Mar 2019 00:00:00 GMT;&#39;]) 当登录后的用户发起 http://www.a.com/delete?id=666666 请求时，会删除 id 为 666666 的帖子。 CSRF攻击者准备的\b网站B：&lt;img src=&quot;http://www.a.com/delete?id=666666&quot;&gt; 当登录用户访问攻击者的网站B时，会向 www.a.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.a.com 的帖子页面刷新，会发现ID 为 666666 的帖子已经被删除。 在站点没有做做任何 CSRF 防御的情况下，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 2. CSRF攻击的防范1.验证 HTTP Referer 字段 2.添加 Token 验证 3.限制 Cookie 4.验证码 尽管CSRF听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行(因此对其进行防范的资源也相当稀少)和难以防范，所以被认为比XSS更具危险性。但往往同XSS一同作案! 三、URL跳转漏洞 借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 当用户点击后,经过服务器或者浏览器解析后，将会跳到恶意的网站中。 http://a.baidu.com/index?act=go&amp;url=http://evil.cn/ http://b.baidu.com/safecheck.html?id=1&amp;url=http://evil.cn/ http://c.baidu.com/f/user/passport?jumpUrl=http://evil.cn/ 1. 实现方式 META标签内跳转 Javascript跳转 Header头跳转 通过以GET或者POST的方式接收将要跳转的URL，然后通过上面的几种方式的其中一种来跳转到目标URL。一方面，由于用户的输入会进入Meta，javascript，http头所以都可能发生相应上下文的漏洞，如xss等等，但是同时，即使只是对于URL跳转本身功能方面就存在一个缺陷，因为会将用户浏览器从可信的站点导向到不可信的站点，同时如果跳转的时候带有敏感数据一样可能将敏感数据泄漏给不可信的第三方。 2. 防御方案① referer的限制如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接 ② 加入有效性验证Token我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。 四、ClickJacking ClickJacking点击劫持，也叫UI覆盖攻击，攻击者会利用一个或多个透明或不透明的层来诱骗用户支持点击按钮的操作，而实际的点击确实用户看不到的一个按钮，从而达到在用户不知情的情况下实施攻击。 1. iframe覆盖这种攻击方式的关键在于可以实现页中页的&lt;iframe&gt;标签，并且可以使用css样式表将他不可见。 防止点击劫持有两种主要方法： X-FRAME-OPTIONSX-FRAME-OPTIONS是微软提出的一个http响应首部，指示浏览器不允许从其他域进行取景，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。DENY : 拒绝任何域加载SAMEORIGIN : 允许同源域下加载ALLOW-FROM : 可以定义允许frame加载的页面地址 顶层判断在UI中采用防御性代码，以确保当前帧是最顶层的窗口,如:top != self || top.location != self.location || top.location != location 2. 图片覆盖图片覆盖攻击（Cross Site Image Overlaying），攻击者使用一张或多张图片，利用图片的style或者能够控制的CSS，将图片覆盖在网页上，形成点击劫持。当然图片本身所带的信息可能就带有欺骗的含义，这样不需要用户点击，也能达到欺骗的目的。 html123&lt;a href=\"http://www.a.com/delete?id=666666\"&gt; &lt;img src=\"~~~\" style=\"~~~\" /&gt;&lt;/a&gt; 解决方案: 在防御图片覆盖攻击时，需要检查用户提交的HTML代码中，img标签的style属性是否可能导致浮出。 五、SQL Injection SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 1. 原理SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面： ① 不当的类型处理；② 不安全的数据库配置；③ 不合理的查询集处理；④ 不当的错误处理；⑤ 转义字符处理不合适；⑥ 多个提交处理不当。 2. 攻击当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击。如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的字符串来传递，也会发生sql注入。sql注入可能导致攻击者使用应用程序登陆在数据库中执行命令。相关的SQL注入可以通过测试工具pangolin进行。 3. 防护① 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。② 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。③ 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。④ 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。⑤ 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装⑥ sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 六、OS命令注入 OS 注入攻击是指程序提供了直接执行 Shell 命令的函数的场景，当攻击者不合理使用，且开发者对用户参数未考虑安全因素的话，就会执行恶意的命令调用，被攻击者利用。 OS 命令注入其实原理和 SQL 注入是类似的，只是场景不一样而已。在 Node.js 中可以使用 exec() 执行命令通过传入一段字符串命令，并把一个错误或命令处理结果回传至回调函数中。 1. execnode1234let userInput = \"user input\";child_process.exec('ls -l ' + userInput, (err, data) =&gt; &#123; console.log(data);&#125;); 攻击者可以使用一个分号”;”来结束命令，并开始一个新的调用，他们可以使用反引号或$()来运行子命令。还有很多潜在的滥用。 在child_process.exec引擎下，将调用执行”/bin/sh”。而不是目标程序。已发送的命令只是被传递给一个新的”/bin/ sh’进程来执行shell。 child_process.exec的名字有一定误导性 - 这是一个bash的解释器，而不是启动一个程序。这意味着，如果直接执行用户输入的参数，所有的shell字符可能会产生毁灭性的后果。 2. execFile/spawn在 Node.js 中除了 exec() 之外，还有 execFile() 和 spawn() 两个方法也可以用来执行系统命令。它们和 exec() 的区别是后者是直接将一个命令字符串传给 /bin/sh 执行，而前者是提供了一个数组作为参数容器，最后参数会被直接传到 C 的命令执行方法 execve() 中，不容易执行额外的参数。 child_process.execFile1234let path = \"user input\";child_process.execFile('/bin/ls', ['-l', path], (err, result) =&gt; &#123; console.log(result)&#125;); child_process.spawn123456let path = \"user input\";let ls = child_process.spawn('/bin/ls', ['-l', path])ls.stdout.on('data', data =&gt; &#123; console.log(data.toString());&#125;); 注意：使用spawn或execFile并不总是安全的。例如，运行 /bin/find，并传入用户输入参数仍有可能导致系统被攻陷。 find命令有一些选项，允许读/写任意文件。 避免使用child_process.exec，当需要包含用户输入的参数时更是如此，请牢记。 尽量避免让用户传入参数，使用选择项比让用户直接输入字符串要好得多。 必须允许用户输入参数的情况下，请广泛参考该命令的参数，确定哪些选项是安全的，并建立一个白名单。 参考文章： 常见六大Web安全攻防解析 Web安全的三个攻防姿势 关于Web安全的三个攻防姿势","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.williamife.com/tags/Web安全/"}]},{"title":"解决跨域的N种方法","slug":"解决跨域的N种方法","date":"2019-03-11T02:40:00.000Z","updated":"2020-08-11T09:06:36.189Z","comments":true,"path":"2019/03/11/解决跨域的N种方法/","link":"","permalink":"https://www.williamife.com/2019/03/11/解决跨域的N种方法/","excerpt":"","text":"一、什么是同源策略同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 当协议、域名、端口号，有一个或多个不同时，有希望可以访问并获取数据的现象称为跨域访问，同源策略限制下 cookie、localStorage、dom、ajax、IndexDB 都是不支持跨域的。 但是有三个标签是允许跨域加载资源： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://a.com/b.js 主域相同，子域不同 不允许 http://www.b.com/a.js http://www.a.com/b.js 不同域名 不允许 二、CORS CORS是一个W3C标准，全称是跨域资源共享（Cross-Origin Resource Sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 1. 简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。) 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。(因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。) 2. 请求分类 简单请求（simple request） 请求方式为HEAD、POST 或者 GEThttp头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain) 非简单请求（not-so-simple request） 凡是不满足上述条件，就属于非简单请求。比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 3. 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0 ... Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头 Access-Control-Allow-Origin:该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。Access-Control-Expose-Headers:该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 123456789101112131415// IE8/9需用window.XDomainRequest兼容let xhr = new XMLHttpRequest();// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 4. 非简单请求非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求preflight 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 let url = &apos;http://api.alice.com/cors&apos;; let xhr = new XMLHttpRequest(); xhr.open(&apos;PUT&apos;, url, true); xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;); xhr.send(); 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0 ... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示api.bob.com可以请求数据。 该字段也可以设为星号，表示同意任意跨源请求。如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 服务器回应的其他CORS相关字段如下： Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。Access-Control-Allow-Credentials：该字段与简单请求时的含义相同。Access-Control-Max-Age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器正常请求回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 浏览器的正常CORS请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 5. 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 三、WebSocket Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。 WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 我们推荐使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 html12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;WebSocket&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Try Me：&lt;input type=\"text\"&gt;&lt;/div&gt; &lt;script&gt; // 创建 webSocket const socket = new WebSocket('ws://localhost:3000'); // 连接上触发 socket.onopen = function () &#123; socket.send('Hello World!'); &#125; socket.onconnect = function () &#123; // 监听服务端消息 socket.onmessage = function (e) &#123; console.log(e.data); &#125; &#125; // 监听服务端关闭 socket.onclose = function () &#123; console.log('Server socket has closed.'); &#125; document.getElementsByTagName('input')[0].onblur = function () &#123; socket.send(this.value); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Node.js1234567891011121314151617181920212223242526272829const http = require('http');const socket = require('ws');const fs = require('fs');// 启http服务const server = http.createServer(function (req, res) &#123; const content = fs.readFileSync('./html.html'); res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.write(content); res.end();&#125;);server.listen('8000');console.log('Server is running at port 8000...');// 监听socket连接const wss = new socket.Server(&#123; port: 3000 &#125;);wss.on('connection', function (client) &#123; // 接收信息 client.on('message', function (msg) &#123; client.send('我接收到了：' + msg); console.log('data from client: ---&gt; ' + msg); if (msg === '666') &#123; client.send(999); &#125; &#125;); // 断开处理 client.on('close', function () &#123; console.log('Client socket has closed.'); &#125;);&#125;); 该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 GET / HTTP/1.1 Upgrade: websocket Connection: Upgrade Host: example.com Origin: http://example.com Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== Sec-WebSocket-Version: 13 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= 首部字段名 说明 Connection 必须设置 Upgrade，表示客户端希望连接升级。 Upgrade 必须设置 Websocket，表示希望升级到 Websocket 协议。 Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。 Sec-WebSocket-Version 表示支持的 Websocket 版本。RFC6455 要求使用的版本是 13，之前草案的版本均应当弃用。 Sec-WebSocket-Accept 由Sec-WebSocket-Key进行BASE-64编码返回。 Sec-WebSocket-Extensions 协议扩展。 四、postMessage window.postMessage(message，targetOrigin)方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。 调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。 页面https://www.williamife.com/a.html的代码： 123456789101112&lt;iframe src=\"https://williamife.com/b.html\" id=\"myIframe\" onload=\"test()\" style=\"display: none;\"&gt;&lt;script&gt; // 1. iframe载入 \"https://williamife.com/b.html\"页面后会执行该函数 function test() &#123; // 2. 获取 https://williamife.com/b.html 页面的 window 对象， let iframe = document.getElementById('myIframe'); let win = iframe.contentWindow; // 然后通过 postMessage 向 https://williamife.com/b.html 页面发送消息 win.postMessage('我是来自https://www.williamife.com/a.html页面的消息', '*'); &#125;&lt;/script&gt; 页面 https://williamife.com/b.html 的代码： 1234567&lt;script type=\"text/javascript\"&gt; // 注册 message 事件用来接收消息 window.onmessage = function(e) &#123; e = e || event; // 获取事件对象 console.log(e.data); // 通过 data 属性得到发送来的消息 &#125;&lt;/script&gt; 五、JSONP 由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。 123456789101112131415161718// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据function handleResponse(data) &#123; console.log(data);&#125;;// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponselet body = document.getElementsByTagName('body')[0];let script = document.gerElement('script');script.src = 'https://www.williamife.cn/json?callback=handleResponse';body.appendChild(script);// 3. 通过 script请求 `https://www.williamife.cn/json?callback=handleResponse`，// 4. 后端能够识别这样的 URL 格式并处理该请求，// 然后返回 handleResponse(&#123;\"name\": \"william\"&#125;) 给浏览器// 5. 浏览器在接收到 handleResponse(&#123;\"name\": \"william\"&#125;) 之后立即执行 ，// 也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。 JSONP只能发GET请求，因为本质上script加载资源就是GET，那么如果要发POST请求怎么办呢？ 12345678910111213141516171819202122232425262728293031323334353637const requestPost = (&#123;url, data&#125;) =&gt; &#123; // 首先创建一个用来发送数据的iframe. const iframe = document.createElement('iframe') iframe.name = 'iframePost' iframe.style.display = 'none' document.body.appendChild(iframe) const form = document.createElement('form') const node = document.createElement('input') // 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话. iframe.addEventListener('load', function () &#123; console.log('post success') &#125;) form.action = url // 在指定的iframe中执行form form.target = iframe.name form.method = 'post' for (let name in data) &#123; node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) &#125; // 表单元素需要添加到主文档中. form.style.display = 'none' document.body.appendChild(form) form.submit() // 表单提交后,就可以删除这个表单,不影响下次的数据发送. document.body.removeChild(form)&#125;// 使用方式requestPost(&#123; url: 'http://localhost:8080/api/iframePost', data: &#123; msg: 'helloIframePost' &#125;&#125;) 自己实现一个JSONP 12345678910111213141516171819202122232425262728293031323334353637383940const jsonp = function(url,data)&#123; return new Promise((resolve,reject) =&gt; &#123; // 处理url地址,查找？，如果没有？这个变量就有一个\"?\"，有？这个变量接收一个&amp; let dataString = url.indexOf('-1') === -1? '?' : '&amp;' // 处理回调函数名 let callbackName = `jsonpCB_$&#123;Date.now()&#125;` url += `$&#123;dataString&#125;callback=$&#123;callbackName&#125;` // 处理参数&#123;xx:xx&#125; for (let k in data) &#123; url += `&amp;$&#123;k&#125;=$&#123;data[k]&#125;` //?k=data[k] &#125; // 创建script标签 let jsNode = document.createElement('script') jsNode.src = url // 触发callback，触发后删除js标签和绑定在window上的callback window[callbackName] = result =&gt; &#123; delete window[callbackName] document.body.removeChild(jsNode) result ? resolve(result) : reject('错误') &#125; // js加载异常的情况 jsNode.addEventListener('error',() =&gt;&#123; delete window[callbackName] document.body.removeChild(jsNode) reject('错误') &#125;,false) // 添加js节点到document上时，开始请求 document.appendChild(jsNode) &#125;)&#125;jsonp('http://192.168.0.1:8080/jsonp', &#123;a: 1, b: '2'&#125;) .then(result =&gt; &#123; console.log(result) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 六、window.name 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 1234567// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右// 数据格式可以自定义，如json、字符串window.name = \"这是a页面的内容\";setTimeout(function()&#123; window.location.href= b.html; console.log(window.name); //\"这是a页面的内容\"&#125;,2000); 有时候我们的需求是在a页面内，获得ccc上的数据，并且页面不能进行刷新。 对于这种需求，我们不能通过window.location.href更新页面来获得数据，我们可以用一个隐藏的iframe作为中间的代理，iframe的src为https://xxx.ccc.com/xxx，在iframe页面加载完毕的时候，我们再让iframe与当前页面属于同一个域下，我们就可以拿到window.name了。 123456789101112131415161718192021222324let boo = false;let iframe = document.createElement('iframe');let loadData = function() &#123; if (boo) &#123; //获取window.name let data = iframe.contentWindow.name; console.log(data); //销毁数据 iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125; else &#123; boo = true; // 设置的代理文件,iframe重新载入 iframe.contentWindow.location = \"b.html\"; &#125; &#125;;iframe.src = 'https://xxx.ccc.com/xxx';if (iframe.attachEvent) &#123; iframe.attachEvent('onload', loadData);&#125; else &#123; iframe.onload = loadData;&#125;document.body.appendChild(iframe); 优点: window.name容量很大，可以放置非常长的字符串；缺点: 必须监听子窗口window.name属性的变化，影响网页性能。 七、location.hash 与 window.name 跨域的情况相同，是不同域的页面间的参数传递，需要借助 iframe 标签，A 页面和 B 页面是同域的 ，C 页面是独立的域。 HTML A12345678&lt;!-- https://www.williamife/a.html --&gt;&lt;iframe src=\"http://www.c.html#123\" id=\"frame\"&gt;&lt;/iframe&gt;&lt;script&gt; // 使用 hashchange 事件接收来自 B 页面设置给 A 页面的 hash 值 window.onhashchange = function() &#123; console.log(location.hash); &#125;&lt;/script&gt; HTML C12345// 打印 A 页面引入 C 页面设置的 hash 值console.log(location.hash);let iframe = document.createElement('iframe');iframe.src = 'https://www.williamife/b.html#456';document.body.appendChild(iframe); HTML B12// 将 C 页面引入 B 页面设置的 hash 值设置给 A页面window.parent.parent.location.hash = location.hash; 八、document.domain 这种跨域的方式最主要的是要求主域名相同。 页面https://www.williamife.com/a.html的代码： 12345678910&lt;iframe src=\"https://williamife.com/b.html\" id=\"myIframe\" onload=\"test()\" style=\"display: none;\"&gt;&lt;script type=\"text/javascript\"&gt; document.domain = 'williamife.com';//设置成主域 function test()&#123; //contentWindow 可取得子窗口的 window 对象 console.log(document.getElementById('iframe').contentWindow); &#125;&lt;/script&gt; 页面 https://williamife.com/b.html 的代码： 1234&lt;script type=\"text/javascript\"&gt; //在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同 document.domain = 'williamife.com';&lt;/script&gt; 九、图像 Ping 由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。 直接通过下面的例子来说明图像 Ping 实现跨域的流程： 1234567let img = new Image();// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本img.onload = img.onerror = function() &#123; console.log(\"Done!\");&#125;// 请求数据通过查询字符串形式发送img.src = 'https://www.williamife.com/getinfo?name=william'; 优点:用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。 缺点:只支持 GET 请求。只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。 十、其它方案1. WebServer: nginxNginx1234567891011server&#123; # 监听9099端口 listen 9099; # 域名是localhost server_name localhost; #凡是localhost:9099/api这个样子的， #都转发到真正的服务端地址https://www.williamife.com location ^~ /api &#123; proxy_pass https://www.williamife.com; &#125;&#125; JavaScript12345678910111213// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，// 然后Nginx监听到凡是localhost:9099/api这个样子的，// 都转发到真正的服务端地址https://www.williamife.comfetch( 'http://localhost:9099/api/iframePost' , &#123; method: 'POST' , headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; msg: 'helloIframePost' &#125;)&#125;) 2. Node中间件: http-proxy-middlewarenode + webpack + webpack-dev-serve123456789101112131415module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://xxxxxxxx:8000', // 代理服务器路径 pathRewrite: &#123;'^/api' : '/'&#125;, // 重写路径 changeOrigin: true &#125; ... &#125; &#125;&#125; 3. canvas: getImageData,toDataURL可移步至张鑫旭的文章查看 参考文章： HTML5 WebSocket WebSocket 教程 JS跨域 MDN Web Docs","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.williamife.com/tags/HTTP/"}]},{"title":"从HTTP到WEB缓存","slug":"从HTTP到WEB缓存","date":"2019-03-04T00:00:00.000Z","updated":"2019-07-10T05:43:49.591Z","comments":true,"path":"2019/03/04/从HTTP到WEB缓存/","link":"","permalink":"https://www.williamife.com/2019/03/04/从HTTP到WEB缓存/","excerpt":"","text":"一、HTTP 概述 HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。 客户端和服务端通过交换各自的消息（与数据流正好相反）进行交互。由像浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫做 responses。 1. 基本性质 HTTP是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。 HTTP是可扩展的：在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。使用Cookies可以创建有状态的会话。 2. HTTP 消息结构1. 请求报文HTTP请求报文由：请求行、请求头部、空行和请求数据四个部分组成。 2. 响应报文HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 二、HTTP 请求方法 根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法：GET, POST , HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE , CONNECT 方法。 方法 描述 GET 请求获取Request-URI所标识的资源。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除 Request-URI 所标识的资源。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器，主要使用SSL和TLS将数据加密后通过网络隧道进行传输。 OPTIONS 使服务器传回该资源所支持的所有HTTP请求方法。用 * 来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 其中，最常见的是 GET 和 POST 方法，如果是 RESful 接口的话一般会用到 PUT、DELETE、GET、POST（分别对应增删查改） 三、HTTP 首部主要分为通用首部、请求首部、响应首部和实体首部四种： 通用首部字段：既可以出现在请求报文中，也可以出现在响应报文中，它提供了与报文相关的最基本的信息； 请求首部字段：从客户端向服务器发送请求报文时使用的首部字段，补充了请求的附加内容，客户端信息，响应内容相关优先级等信息； 响应首部字段：从服务器向客户端返回响应报文时使用的首部字段；补充了响应的附加内容，也会要求客户端附加额外的内容信息； 实体首部字段：针对请求报文和响应报文的实体部分使用的首部，补充了资源内容的更新时间等与实体有关的信息。 其他报文字段：这些字段不是HTTP协议中定义的，但被广泛应用于HTTP请求中。 1. 通用首部字段 首部字段名 说明 Cache-Control 控制缓存行为。 Connection 管理持久连接，设置其值为Keep-Alive可实现长连接。 Date 创建HTTP报文的日期和时间。 Pragma Http/1.1之前的历史遗留字段，仅作为HTTP/1.0向后兼容而定义，虽然是通用字段，当通常被使用在客户单的请求中，如Pragma: no-cache, 表示客户端在请求过程中不循序服务端返回缓存的数据。 Trailer 报文尾部的首部。 Transfer-Encoding 规定了传输报文主题时使用的传输编码，如Transfer-Encoding: chunked。 Upgrade 用于检查HTTP协议或其他协议是否有可使用的更高版本。 Via 追踪客户端和服务端之间的报文的传输路径，还可避免会环的发生，所以在经过代理时必须添加此字段。 Warning Http/1.1的报文字段，从Http/1.0的AfterRetry演变而来，用来告知用户一些与缓存相关的警告信息。 2. 请求首部字段 首部字段名 说明 Accept 客户端能够处理的媒体类型 Accept-Charset 表示客户端支持的字符集。例如：Accept-Charset: GB2312, ISO-8859-1 Accept-Encoding 表示客户端支持的内容编码格式。如：Accept-Encoding：gzip Accept-Language 表示客户端支持的语言。如：Accept-Language: zh-cn, en Authorization 表示客户端的认证信息。客户端在访问需要认证的也是时，服务器会返回401，随后客户端将认证信息加在Authorization字段中发送到服务器后，如果认证成功，则返回200 Host 表示访问资源所在的主机名，即URL中的域名部分。如：m.baidu.com If-Match If-Match的值与所请求资源的ETag值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时，服务器才处理此请求 If-Modified-Since 用于确认客户端拥有的本地资源的时效性 If-None-Match If-Match的值与所请求资源的ETag值不一致时服务器才处理此请求 If-Range If-Range的值（ETag值或时间）与所访问资源的ETag值或时间相一致时，服务器处理此请求，并返回Range字段中设置的指定范围的数据。如果不一致，则返回所有内容。If-Range其实算是If-Match的升级版，因为它的值不匹配时，依然能够返回数据，而If-Match不匹配时，请求不会被处理，需要数据时需再次进行请求 If-Unmodified-Since 与If-Modified-Since相反，表示请求的资源在指定的时间之后未发生变化时，才处理请求，否则返回412 Max-Forwards 表示请求可经过的服务器的最大数目，请求每被转发一次，Max-Forwards减1，当Max-Forwards为0时，所在的服务器将不再转发，而是直接做出应答。通过此字段可定位通信问题 Proxy-Authorization 当客户端接收到来自代理服务器的认证质询时，客户端会将认证信息添加到Proxy-Authorization来完成认证。与Authorization类似，只不过Authorization是发生在客户端与服务端之间 Range 获取部分资源，例如：Range: bytes=500-1000表示获取指定资源的第500到1000字节之间的内容，如果服务器能够正确处理，则返回206作为应答，表示返回了部分数据，如果不能处理这种范围请求，则以200作为应答，返回完整的数据 Referer 告知服务器请求是从哪个页面发起的 User-Agent 将发起请求的浏览器和代理名称等信息发送给服务端 Cookie 在请求时添加Cookie, 以实现HTTP的状态记录 3. 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围。 Age 服务端告知客户端，源服务器（而不是缓存服务器）在多久之前创建了响应，单位为秒。 ETag 实体资源的标识，可用来请求指定的资源。 Location 请求的资源所在的新位置。 Proxy-Authenticate 将代理服务器需要的认证信息发送给客户端。 Retry-After 服务端告知客户端多久之后再重试，一般与503和3xx重定向类型的应答一起使用。 Server 告知服务端当前使用的HTTP服务器应用程序的相关信息。 Vary 代理服务器缓存的管理信息。 WWW-Authenticate 告知客户端适用于所访问资源的认证方案，如Basic或Digest。401的响应中肯定带有WWW-Authenticate字段。 Set-Cookie 服务器通过此字段给客户端传递Cookie信息。 4. 实体首部字段 首部字段名 说明 Allow 通知客户端，服务器所支持的请求方法。 Content-Encoding 告知客户端，服务器对资源的内容编码。 Content-Language 告知客户端，资源所使用的自然语言。 Content-Length 告知客户端资源的长度 Content-Location 告知客户端资源所在的位置。 Content-Type 告知客户端资源的媒体类型，取值同请求首部字段中的Accept。 Expires 告知客户端资源的失效日期。可用于对缓存的处理。 Last-Modified 告知客户端资源最后一次修改的时间。 5. 其他报文字段X-Frame-Options：首部字段X-Frame-Options属于HTTP响应首部用于控制网站内容在其他Web网站的Frame标签内的显示问题，主要目的是为了防止点击劫持攻击 X-XSS-Protection：首部字段X-XSS-Protection属于HTTP响应首部针对跨站脚本攻击的一种对策,用于控制浏览器XSS防护机制的开关 DNT(Do Not Track)：拒绝个人信息被收集,表示拒绝被精准广告追踪的一种方法 四、HTTP 状态返回码 状态码负责表示客户端请求的返回结果、标记服务器端是否正常、通知出现的错误。 状态码 类别 分类描述 1XX Informational（信息性状态码） 请求正在被处理 2XX Success（成功状态码） 请求处理成功 3XX Redirection（重定向状态码） 需要进行重定向 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态吗） 服务器处理请求时出错 1. 信息响应 状态码 短句 含义 100 Continue 继续，客户端应继续其请求 101 Switching Protocols 切换协议，只能切换到更高级的协议 2. 成功响应 状态码 短句 含义 200 OK 请求成功，一般用于GET与POST请求 201 Created 已创建，成功请求并创建了新的资源 202 Accepted 已接受，已经接受请求，但未处理完成 3. 重定向 状态码 短句 含义 300 Multiple Choices 多种选择，请求的资源可包括多个位置 301 Moved Permanently 永久移动 302 Found 临时移动，GET 或者 HEAD 请求 303 See Other 查看其它地址，与302类似。需使用GET请求查看 304 Not Modified 未修改，服务器返回此状态码时，不会返回任何资源 307 Temporary Redirect 临时重定向，不该改变请求方法 4. 客户端错误 状态码 短句 含义 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页） 405 Method Not Allowed 客户端请求中的方法被禁止 5. 服务器错误 状态码 短句 含义 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 从远程服务器接收到了一个无效的响应 503 Service Unavailable 服务器暂时的无法处理客户端的请求 504 Gateway Time-out 未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 五、HTTP 内容类型Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。 常见的媒体类型：文本文件：text/html, text/plain, text/css, application/xml图片文件：iamge/jpeg, image/gif, image/png;视频文件：video/mpeg应用程序使用的二进制文件：application/octet-stream, application/zip 常用的内容编码：gzip: 由文件压缩程序gzip生成的编码格式；compress: 由Unix文件压缩程序compress生成的编码格式；deflate: 组合使用zlib和deflate压缩算法生成的编码格式；identity：默认的编码格式，不执行压缩。 Cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly (1) 会话期Cookie浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 (2) 持久性Cookie和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。 (3) Secure 和 HttpOnly 标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。 为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。 (4) Cookie的作用域Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。 七、HTTP/1.x的连接管理连接管理是一个 HTTP 的关键话题：打开和保持连接在很大程度上影响着网站和 Web 应用程序的性能。在 HTTP/1.x 里有多种模型：短连接, 长连接, 和 HTTP 流水线。 短连接HTTP 最早期的模型，也是 HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。 长连接一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。 HTTP 流水线HTTP 流水线在现代浏览器中并不是默认被启用的HTTP/2 流水线已经被更好的算法给代替，如 multiplexing 域名分片 除非你有紧急而迫切的需求，不要使用这一过时的技术，升级到 HTTP/2 就好了。在 HTTP/2 里，做域名分片就没必要了：HTTP/2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP/2 的实现还会使用一种称作连接凝聚的技术去尝试合并被分片的域名。 如果服务器端想要更快速的响应网站或应用程序的应答，它可以迫使客户端建立更多的连接。 浏览器有并发限制，是为了防止Dos/DDoS攻击。 例如，不要在同一个域名下获取所有资源，假设有个域名是www.example.com我们可以把它拆分成好几个域名：www1.example.com、www2.example.com所有这些域名都指向同一台服务器，浏览器会同时为每个域名建立多条连接。 这一技术被称作域名分片（域名发散） 域名收敛 就是将静态资源放在一个域名下,减少DNS解析的开销。 八、HTTP 缓存 重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。 1. 各种类型的缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。 缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用，私有缓存只能用于单独用户。 下文将主要介绍浏览器缓存，除此之外还有代理缓存、网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上，为站点和 web 应用提供更好的稳定性、性能和扩展性。 常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。 2. 缓存规则为了方便理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息（实际上静态资源是被缓存到了内存和磁盘中），在浏览器第一次请求数据时，此时缓存数据库没有对应的缓存数据，则需要请求服务器，服务器会将缓存规则和数据返回，浏览器将缓存规则和数据存储进缓存数据库。 我们可以将其分为两大类强缓存、协商缓存 2.1 强缓存浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求(200 from memory/disk cache) HTTP 1.0 服务器使用的响应头字段为 Expires ，值为未来的绝对时间（时间戳），浏览器请求时的当前时间超过了 Expires 设置的时间，代表缓存失效，需要再次向服务器发送请求，否则都会直接从缓存数据库中获取数据。 HTTP 1.1 Cache-Control 是最重要的规则，默认为private。 private 私有缓存 public 共享缓存 max-age 缓存的内容将在 xxx 秒后失效 no-cache 需要使用对比缓存来验证缓存数据 no-store 所有内容都不会缓存，强缓存、协商缓存都不会触发 注意：在 HTTP 1.0 版本中，Expires 字段的绝对时间是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 HTTP 1.1 版本中，因为 Cache-Control 的值 max-age=xxx 中的 xxx 是以秒为单位的相对时间，所以在浏览器接收到资源后开始倒计时，规避了 HTTP 1.0 中缓存命中存在误差的缺点，为了兼容低版本 HTTP 协议，正常开发中两种响应头会同时使用，HTTP 1.1 版本的实现优先级高于 HTTP 1.0。 2.2 协商缓存浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 HTTP 1.0 If-Modified-Since/Last-Modified这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到s。 HTTP 1.1 If-None-Match/E-tag这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，只要文件变，指纹就会变，而且没有精确度的限制。 为了使缓存策略更加健壮、灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略会同时使用，甚至强制缓存和协商缓存也会同时使用，对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，超出有效时间，执行协商缓存策略，对于协商缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求头 If-None-Match 和 If-Modified-Since 发送给服务器，由服务器校验同时设置新的强制缓存，校验通过并返回 304 状态码时，浏览器直接使用缓存，如果协商缓存也未命中，则服务器重新设置协商缓存的标识。 3. 带Vary头的响应 Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。 使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助 Google 或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入Cloaking。 参考文章： 彻底弄懂HTTP缓存机制及原理 关于HTTP协议，一篇就够了 MDN Web Docs","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.williamife.com/tags/HTTP/"}]},{"title":"从URL输入到页面展现到底发生什么？","slug":"从URL输入到页面展现到底发生什么","date":"2019-02-16T08:30:00.000Z","updated":"2019-11-27T07:53:03.571Z","comments":true,"path":"2019/02/16/从URL输入到页面展现到底发生什么/","link":"","permalink":"https://www.williamife.com/2019/02/16/从URL输入到页面展现到底发生什么/","excerpt":"","text":"从开发&amp;运维角度方面来看，总体来说分为以下几个过程： DNS 解析:将域名解析成 IP 地址 TCP 连接：TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接：TCP 四次挥手 一、什么是URLURL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。 scheme: // host.domain:port / path / filename ? abc = 123 # 456789 scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file， 其中最常见的类型是 http，而 https 则是进行加密的网络传输。 host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 baidu.com port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 query - 即查询参数 fragment - 即 # 后的hash值，一般用来定位到某个位置 二、DNS域名解析在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。 IP 地址IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 什么是域名解析DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。 浏览器如何通过域名去查询 URL 对应的 IP 呢？DNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。 DNS的优化与应用 DNS缓存DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 DNS负载均衡(DNS重定向)DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。 大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。 dns-prefetchDNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。 OSI参考模型与TCP/IP四层模型 三、TCP三次握手 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了） 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧） 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧） 四、发送 HTTP 请求TCP 三次握手结束后，开始发送 HTTP 请求报文。 为避免篇幅过长，http协议、缓存等相关内容请移步至：从HTTP到WEB缓存 五、服务器处理请求并返回 HTTP 报文每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。 假装我是一个传统的MVC模型，RD同学请无视 六、浏览器解析渲染页面浏览器的主要构成 用户界面 (User Interface) － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分 浏览器引擎 (Browser Engine) － 用来查询及操作渲染引擎的接口 渲染引擎 (Rendering Engine) － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 网络 (Networking) － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 JS解释器 (JS Interpreter) － 用来解释执行JS代码 UI后端 (UI Backend) － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 数据存储 (DB Persistence) － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 1.多进程的浏览器浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程 进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等… 1.Browser进程：浏览器的主进程（负责协调、主控），只有一个 2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 3.GPU进程：最多一个，用于3D绘制 4.浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染， 脚本执行，事件处理等 (有时候会优化，如多个空白tab会合并成一个进程） 2.多线程的浏览器内核每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程： 1. GUI线程 2. JS引擎线程 3. 事件触发线程 4. 定时器线程 5. 网络请求线程 浏览器的渲染过程浏览器内核拿到内容后，渲染步骤大致可以分为以下几步： 1. 解析HTML，构建DOM树 2. 解析CSS，生成CSS规则树 3. 合并DOM树和CSS规则，生成render树 4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 5. 绘制render树（paint），绘制页面像素信息 以webkit内核为例 1. HTML解析，构建DOM简单的理解，这一步的流程是这样的：浏览器解析HTML，构建DOM树。解析HTML到构建出DOM当然过程可以简述如下： Bytes → characters → tokens → nodes → DOM 其中比较关键的几个步骤 Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符 Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集 Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则 DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象 2. 解析CSS，生成CSS规则树同理，CSS规则树的生成也是类似。 Bytes → characters → tokens → nodes → CSSOM 3. 合并DOM树和CSS规则，生成render树当DOM树和CSSOM都有了后，就要开始构建渲染树了 一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应,因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等 4. 布局render树（Layout/Reflow），负责各元素尺寸、位置的计算布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。 5. 绘制render树（Paint），绘制页面像素信息绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。 这张图片中重要的四个步骤 1. 计算CSS样式 2. 构建渲染树 3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性 4. 绘制，将图像绘制出来 Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树 Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了 七、断开连接当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧) 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧) 参考文章： 从输入URL到页面加载的过程 TCP/IP协议 TCP的三次握手与四次分手 MDN Web Docs","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"https://www.williamife.com/tags/开发/"},{"name":"运维","slug":"运维","permalink":"https://www.williamife.com/tags/运维/"}]},{"title":"关于JS隐式转换的那些小事儿","slug":"JS隐式转换","date":"2018-12-23T11:30:37.000Z","updated":"2019-07-10T05:43:49.588Z","comments":true,"path":"2018/12/23/JS隐式转换/","link":"","permalink":"https://www.williamife.com/2018/12/23/JS隐式转换/","excerpt":"","text":"带你深入浅出的理解隐式转换时js计算中的过程 一、基础概念回顾什么是隐式转换JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据： var foo = 42; // foo is a Number now foo = \"bar\"; // foo is a String now foo = true; // foo is a Boolean now js中，当运算符在运算时，如果两边数据类型不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算。这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换。 如：1 + &#39;1&#39; // 执行时不会报错 数据类型 JavaScript 中有7种数据类型，可以分为两类：原始类型、对象类型： 基本数据类型(原始类型)：Undefined、 Null、 String、 Number、 Boolean、 Symbol (ES6新增) 复杂数据类型(对象类型)：Object 关于 valueOf() 和 toString()1、valueOf() 默认情况下，valueOf方法由Object后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则valueOf将返回对象本身。 对象 返回值 Array 返回数组对象本身。 Boolean 布尔值。 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。 Function 函数本身。 Number 数字值。 Object 对象本身。这是默认情况。 String 字符串值。 Symbol symbol 原始值。 Math 和 Error 对象没有 valueOf 方法。 2、toString() 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。 对象 返回值 是否覆盖自Object的方法 Array 返回一个字符串，表示指定的数组及其元素。 是 Boolean 返回指定的布尔对象的字符串形式。 是 Date 返回一个字符串，表示该Date对象。 是 Function 返回一个表示当前函数源代码的字符串。 是 Number 返回指定 Number 对象的字符串表示形式。 是 Object 返回一个表示该对象的字符串。 - String 返回指定对象的字符串形式。 是 Symbol symbol 对象的字符串表示。 是 Error 返回一个指定的错误对象（Error object）的字符串表示。 是 Math 没有 toString 方法,方法继承自Object。 否 二、隐式转换规则 隐式转换中主要涉及到三种类型转换： 转成string类型：+(加法运算符，字符串拼接) 转成number类型：++ --(自增自减运算符) ,+ - * / %(算术运算符)&gt; &lt; &gt;= &lt;= == === != !==(关系、比较运算符) 转成boolean类型：&amp;&amp; || !(逻辑且或非运算符) 对象通过ToPrimitive获得原始值将值转为原始值ToPrimitive(),会执行toNumber或者toString的操作 js引擎内部的抽象操作ToPrimitive有着这样的签名：ToPrimitive(input, PreferredType?) input是要转换的值，PreferredType是可选参数，可以是Number或String类型。它只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（否则报错）。 如果PreferredType被标记为Number，则会进行下面的操作流程来转换输入的值。 如果输入的值已经是一个原始值，则直接返回它 否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，如果valueOf()方法的返回值是一个原始值，则返回这个原始值。 否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。 否则，抛出TypeError异常。 如果PreferredType被标记为String，则会进行下面的操作流程来转换输入的值。 如果输入的值已经是一个原始值，则直接返回它 否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。 否则，如果输入的值是一个对象，则调用该对象的valueOf()方法，如果valueOf()方法的返回值是一个原始值，则返回这个原始值。 否则，抛出TypeError异常。 既然PreferredType是可选参数，那么如果没有这个参数时，怎么转换呢？PreferredType的值会按照这样的规则来自动设置： 该对象为Date类型，则PreferredType被设置为String 否则，PreferredType被设置为Number 来看下面的表格 toPrimitive Number String Boolean false 0 “false” false true 1 “true” true 0 0 “0” false 1 1 “1” true “0” 0 “0” true “1” 1 “1” true NaN NaN “NaN” false Infinity Infinity “Infinity” true -Infinity -Infinity “-Infinity” true “” 0 “” false “ “ 0 “ “ true “2” 2 “2” true “two” NaN “two” true [ ] 0 “” true [0] 0 “0” true [1,2] NaN “1,2” true [“one”] NaN “one” true [“one”,”two”] NaN “one,two” true function(){} NaN “function(){}” true { } NaN “[object Object]” true null 0 “null” false undefined NaN “undefined” false 三、举几个栗子1、比较运算符 在 ECMAScript 中，等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。 非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回true。 为确定两个运算数是否相等，这两个运算符都会进行类型转换。 执行类型转换的规则如下： 如果一个运算数是 Boolean值，在检查相等性之前，把它转换成数字值。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。 如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 [] == 0; true // [] => '' => 0 ![] == 0; true // ![] => false => 0 [] == ![]; true // [] => '' => 0 , ![] => false => 0 [] == []; false // 对比的是它们的引用值 {} == !{} false // {} => '[object Object]' => NaN , // !{} => false => 0 {} == {} false // 对比的是它们的引用值 如何使(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)成立？ 1.转换原始值 const a = { i: 1, valueOf: function () { return a.i++; }, toString: function () { return a.i++; } } if (a == 1 && a == 2 && a == 3) { console.log('hello world!'); } //a先会调用valueOf()方法，如有原始值则返回这个原始值 //否则，调用这个对象的toString()方法 //所以改写其中任一方法均可 2.闭包 let a = { [Symbol.toPrimitive]: (function() { let i = 1; return function() { return i++; } })() } 3.Object.defineProperty let val = 1; Object.defineProperty(window, 'a', { get: function() { return val++; } }); 4.数组 var a = [1,2,3]; a.join = a.shift; // 数组的 toString 方法返回一个字符串， // 该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 这么坑的面试题，你咋不上天呢？ 特殊情况（无视规则）：如果数据是undefined 、 null 、 NaN ， 得出固定结果 在检查相等性时，不能把 null 和 undefined 转换成其他值。(重要) undefined == undefined // true undefined === undefined // true undefined == null // true null == null // true null === null // true null == 0 // false null没有转换 NaN == NaN // false NaN === NaN // false NaN == null // false NaN == undefined // false 2、关系运算符 \"2\" > 10; // false 2 < 10 \"2\" > \"10\"; // true 比较的是Unicode \"abc\" > \"b\"; // false 比较的是Unicode \"abc\" > \"abd\" // true 比较的是Unicode,第一个相等且还有后续就对比第二个， // 出大小的结果就终止对比了 3、字符串连接符与算术运算符 1 + \"true\"; // \"1true\" 1 + true; // 2 1 + undefined; // NaN 1 + null; // 1 等等，是不是忘了什么？ 四、 symbol在 JavaScript 中，虽然大多数类型的对象在某些操作下都会自动的隐式调用自身的 valueOf() 方法或者 toString() 方法来将自己转换成一个原始值，但 symbol 对象不会这么干，symbol 对象无法隐式转换成对应的原始值： 123456789101112Object(Symbol(\"foo\")) + \"bar\";// TypeError: can't convert symbol object to primitive// 无法隐式的调用 valueOf() 方法Object(Symbol(\"foo\")).valueOf() + \"bar\";// TypeError: can't convert symbol to string// 手动调用 valueOf() 方法，虽然转换成了原始值，但 symbol 原始值不能转换为字符串Symbol(\"foo\").toString() + \"bar\"// \"Symbol(foo)bar\"，就相当于下面的:Object(Symbol(\"foo\")).toString() + \"bar\";// \"Symbol(foo)bar\"，需要手动调用 toString() 方法才行 换句话说，在 Symbol.toPrimitive() 方法内部判断了值类型，根据类型进行后续不同的操作，而不是简单的调用 toString() &amp; valueOf()方法，对于 Symbol 类型，它的处理就是抛出异常。 资料查阅：MDN 、 w3school","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"}]},{"title":"JS异步发展流程","slug":"JS异步发展流程","date":"2018-12-05T01:39:14.000Z","updated":"2019-11-27T07:52:14.074Z","comments":true,"path":"2018/12/05/JS异步发展流程/","link":"","permalink":"https://www.williamife.com/2018/12/05/JS异步发展流程/","excerpt":"","text":"异步编程的语法目标，就是怎样让它更像同步编程 什么是异步 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 异步执行的运行机制如下: 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 1、回调函数场景： 读取一个文件 1234567891011let fs = require('fs')fs.readFile('./1.txt', 'utf8', function(err, data)&#123; // 回调的特点是第一个参数一般为错误对象 if (err) &#123; // 如果err有值说明程序出错了 console.log(err) &#125; else &#123; // 否则表示成功获取到数据data console.log(data) &#125;&#125;) 当然回调函数也有它的缺点： 无法捕获错误（使用try catch） 123456789101112131415funnction readFile (fileName) &#123; fs.readFile(fileName, 'utf8', function (data) &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) &#125; &#125;)&#125;try &#123; readFile('./1.txt')&#125; catch (e) &#123; // 如果上边读取文件出错，获取不到错误信息 console.log('err', e)&#125; 不能returnreadFile 方法中无法返回读取到文件的内容（data） 回调地狱 123456789101112131415fs.readFile('./data1.txt', 'utf8', function (err, data1) &#123; fs.readFile('./data2.txt', 'utf8', function (err, data2) &#123; fs.readFile('./data3.txt', 'utf8', function (err, data3) &#123; fs.readFile('./data4.txt', 'utf8', function (err, data4) &#123; fs.readFile('./data5.txt', 'utf8', function (err, data5) &#123; console.log(data1, data2, data3, data4, data5) &#125;) &#125;) &#125;) &#125;)&#125;)// 这样的代码称为恶魔金字塔；且有以下问题// 1、代码非常难看// 2、难以维护// 3、效率比较低，因为它们是串行的；一次只能请求一个文件 2、事件发布订阅为了解决回调嵌套的问题 1234567891011121314151617181920let EventEmitter = require('events')// nodejs核心模块之一,包含两个核心方法:// on &gt;&gt; 表示注册监听,emit &gt;&gt; 表示发射事件let eve = new EventEmitter()let html = &#123;&#125; // 存放页面模板和数据eve.on('reading', function (key, value) &#123; html[key] = value if (Object.keys(html).length == 2) &#123; console.log(html) &#125;&#125;)fs.readFile('./template.txt', 'utf8', function (err, template) &#123; eve.emit('reading', template) // 触发reading事件，执行事件的回调函数向html中填入模板&#125;)fs.readFile('./data.txt', 'utf8', function (err, template) &#123; eve.emit('reading', template) // 触发reading事件，执行事件的回调函数向html中填入数据&#125;) 3、哨兵变量事件发布订阅已经可以解决回调嵌套的问题，但是还需要引入events模块；利用哨兵变量一样可以解决回调嵌套的问题，且不需要引入其他模块 1234567891011121314151617181920212223242526272829// 定义一个哨兵函数来处理function done (key, value) &#123; html[key] = value if (Object.keys(html).length == 2) &#123; console.log(html) &#125;&#125;fs.readFile('./template.txt', 'utf8', function (err, template) &#123; done('template', template)&#125;)fs.readFile('./data.txt', 'utf8', function (err, template) &#123; done('data', data)&#125;)// 可以封装一个高阶函数去生成哨兵函数function render (length, cb) &#123; let htm = &#123;&#125; return function (key, value) &#123; html[key] = value if (Object.keys(html).length == length) &#123; cb(html) &#125; &#125;&#125;let done = render(2, function (html) &#123; console.log(html)&#125;) 4、Promise上述方法都是用回调函数来处理异步；我们的目标是把异步往同步的方向靠拢 12345678910//promise的用法不再阐述，可自行查阅文档let promise1 = new Promise(function (resolve, reject) &#123; fs.readFile('./1.txt', 'utf8', function (err, data) &#123; resolve(data) &#125;)&#125;)promise1.then(function (data) &#123; console.log(data)&#125;) 5、Generator当我们在调用一个函数的时候，它并不会马上执行，而是需要我们手动的去执行迭代操作（next方法）；简单来说，调用生成器函数会返回一个迭代器，可以用迭代器来执行遍历每个中断点（yield）调用next方法会有返回值value，是生成器函数对外输出的数据；next方法还可以接受参数，是向生成器函数内部输入的数据 生成器简单使用 123456789101112// 方法名前边加*就是生成器函数function *foo () &#123; var index = 0; while (index &lt; 2) &#123; yield index++; //暂停函数执行，并执行yield后的操作 &#125;&#125;var bar = foo(); // 返回的其实是一个迭代器console.log(bar.next()); // &#123; value: 0, done: false &#125;console.log(bar.next()); // &#123; value: 1, done: false &#125;console.log(bar.next()); // &#123; value: undefined, done: true &#125; 生成器 + Promise解决异步的实现 123456789101112131415161718192021222324252627282930function readFile (filaName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(filename, function (err, data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;function *read() &#123; let template = yield readFile('./template.txt') let data = yield readFile('./data.txt') return &#123; template: template, data: data &#125;&#125;// 生成迭代器r1let r1 = read()let templatePromise = r1.next().valuetemplatePromise.then(function(template) &#123; // 将获取到的template的内容传递给生成器函数 let dataPromsie = r1.next(template).value dataPromise.then(function(data) &#123; //最后一次执行next传入data的值；最后返回&#123;template， data&#125; let result = r1.next(data).value console.log(result) &#125;)&#125;) 生成器 + promise的实现已经有了一些同步的样子;借助一些工具(co)，可以优雅的编写上述的代码 1234567891011121314151617181920//实现 co 方法//参数是一个生成器函数function co (genFn) &#123; let r1 = genFn() return new Promise(function(resolev, reject) &#123; !function next(lastVal) &#123; let p1 = r1.next(lastVal) if (p1.done) &#123; resolve(p1.value) &#125; else &#123; p1.value.then(next, reject) &#125; &#125;() &#125;)&#125;//现在获取上边的result可以这样来取co(read).then(function(result) &#123; console.log(result)&#125;) 6、Async/await Async其实是一个语法糖，它的实现就是将Generator函数和自动执行器（co），包装在一个函数中 12345678910111213141516//实现 co 方法//参数是一个生成器函数async function read() &#123; let template = await readFile('./template.txt'); let data = await readFile('./data.txt'); return template + '+' + data;&#125;// 等同于function read()&#123; return co(function*() &#123; let template = yield readFile('./template.txt'); let data = yield readFile('./data.txt'); return template + '+' + data; &#125;);&#125; 异步编程发展的目标就是让异步逻辑的代码看起来像同步一样，发展到Async/await,是处理异步编程的一个里程碑。 参考文章： js异步发展简史","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.williamife.com/tags/Node-js/"}]}],"categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.williamife.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.williamife.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://www.williamife.com/tags/React/"},{"name":"开发","slug":"开发","permalink":"https://www.williamife.com/tags/开发/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.williamife.com/tags/Node-js/"},{"name":"Linux","slug":"Linux","permalink":"https://www.williamife.com/tags/Linux/"},{"name":"npm","slug":"npm","permalink":"https://www.williamife.com/tags/npm/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.williamife.com/tags/jQuery/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.williamife.com/tags/Nginx/"},{"name":"Libuv","slug":"Libuv","permalink":"https://www.williamife.com/tags/Libuv/"},{"name":"I/O模型","slug":"I-O模型","permalink":"https://www.williamife.com/tags/I-O模型/"},{"name":"Web安全","slug":"Web安全","permalink":"https://www.williamife.com/tags/Web安全/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.williamife.com/tags/HTTP/"},{"name":"运维","slug":"运维","permalink":"https://www.williamife.com/tags/运维/"}]}